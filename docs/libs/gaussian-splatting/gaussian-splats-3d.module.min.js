import * as e from "three";
import {
  Ray as t,
  Plane as n,
  MathUtils as o,
  EventDispatcher as i,
  Vector3 as s,
  MOUSE as r,
  TOUCH as a,
  Quaternion as c,
  Spherical as l,
  Vector2 as h,
} from "three";
const p = new e.Vector3(),
  u = new e.Vector3(),
  d = new e.Vector4(),
  m = new e.Vector4(),
  f = new e.Quaternion(),
  y = new e.Quaternion();
let g, C;
class v {
  static PositionComponentCount = 3;
  static ScaleComponentCount = 3;
  static RotationComponentCount = 4;
  static ColorComponentCount = 4;
  static CompressionLevels = {
    0: {
      BytesPerPosition: 12,
      BytesPerScale: 12,
      BytesPerColor: 4,
      BytesPerRotation: 16,
      ScaleRange: 1,
    },
    1: {
      BytesPerPosition: 6,
      BytesPerScale: 6,
      BytesPerColor: 4,
      BytesPerRotation: 8,
      ScaleRange: 32767,
    },
  };
  static CovarianceSizeFloats = 6;
  static CovarianceSizeBytes = 24;
  static HeaderSizeBytes = 1024;
  constructor(e) {
    (this.headerBufferData = new ArrayBuffer(v.HeaderSizeBytes)),
      (this.headerArrayUint8 = new Uint8Array(this.headerBufferData)),
      (this.headerArrayUint32 = new Uint32Array(this.headerBufferData)),
      (this.headerArrayFloat32 = new Float32Array(this.headerBufferData)),
      this.headerArrayUint8.set(new Uint8Array(e, 0, v.HeaderSizeBytes)),
      (this.versionMajor = this.headerArrayUint8[0]),
      (this.versionMinor = this.headerArrayUint8[1]),
      (this.headerExtraK = this.headerArrayUint8[2]),
      (this.compressionLevel = this.headerArrayUint8[3]),
      (this.splatCount = this.headerArrayUint32[1]),
      (this.bucketSize = this.headerArrayUint32[2]),
      (this.bucketCount = this.headerArrayUint32[3]),
      (this.bucketBlockSize = this.headerArrayFloat32[4]),
      (this.halfBucketBlockSize = this.bucketBlockSize / 2),
      (this.bytesPerBucket = this.headerArrayUint32[5]),
      (this.compressionScaleRange =
        this.headerArrayUint32[6] ||
        v.CompressionLevels[this.compressionLevel].ScaleRange),
      (this.compressionScaleFactor =
        this.halfBucketBlockSize / this.compressionScaleRange);
    const t = e.byteLength - v.HeaderSizeBytes;
    (this.splatBufferData = new ArrayBuffer(t)),
      new Uint8Array(this.splatBufferData).set(
        new Uint8Array(e, v.HeaderSizeBytes, t)
      ),
      (this.bytesPerPosition =
        v.CompressionLevels[this.compressionLevel].BytesPerPosition),
      (this.bytesPerScale =
        v.CompressionLevels[this.compressionLevel].BytesPerScale),
      (this.bytesPerColor =
        v.CompressionLevels[this.compressionLevel].BytesPerColor),
      (this.bytesPerRotation =
        v.CompressionLevels[this.compressionLevel].BytesPerRotation),
      (this.bytesPerSplat =
        this.bytesPerPosition +
        this.bytesPerScale +
        this.bytesPerColor +
        this.bytesPerRotation),
      (g = this.fbf.bind(this)),
      (C = this.tbf.bind(this)),
      this.linkBufferArrays(),
      (this.precomputedCovarianceBufferData = null);
  }
  linkBufferArrays() {
    let e = 0 === this.compressionLevel ? Float32Array : Uint16Array;
    (this.positionArray = new e(
      this.splatBufferData,
      0,
      this.splatCount * v.PositionComponentCount
    )),
      (this.scaleArray = new e(
        this.splatBufferData,
        this.bytesPerPosition * this.splatCount,
        this.splatCount * v.ScaleComponentCount
      )),
      (this.colorArray = new Uint8Array(
        this.splatBufferData,
        (this.bytesPerPosition + this.bytesPerScale) * this.splatCount,
        this.splatCount * v.ColorComponentCount
      )),
      (this.rotationArray = new e(
        this.splatBufferData,
        (this.bytesPerPosition + this.bytesPerScale + this.bytesPerColor) *
          this.splatCount,
        this.splatCount * v.RotationComponentCount
      )),
      (this.bucketsBase = this.splatCount * this.bytesPerSplat);
  }
  fbf(t) {
    return 0 === this.compressionLevel ? t : e.DataUtils.fromHalfFloat(t);
  }
  tbf(t) {
    return 0 === this.compressionLevel ? t : e.DataUtils.toHalfFloat(t);
  }
  buildPreComputedBuffers() {
    const t = this.splatCount;
    this.precomputedCovarianceBufferData = new ArrayBuffer(
      v.CovarianceSizeBytes * t
    );
    const n = new Float32Array(this.precomputedCovarianceBufferData),
      o = new e.Vector3(),
      i = new e.Quaternion(),
      s = new e.Matrix3(),
      r = new e.Matrix3(),
      a = new e.Matrix3(),
      c = new e.Matrix4();
    for (let e = 0; e < t; e++) {
      const t = e * v.ScaleComponentCount;
      o.set(
        g(this.scaleArray[t]),
        g(this.scaleArray[t + 1]),
        g(this.scaleArray[t + 2])
      ),
        c.makeScale(o.x, o.y, o.z),
        r.setFromMatrix4(c);
      const l = e * v.RotationComponentCount;
      i.set(
        g(this.rotationArray[l + 1]),
        g(this.rotationArray[l + 2]),
        g(this.rotationArray[l + 3]),
        g(this.rotationArray[l])
      ),
        c.makeRotationFromQuaternion(i),
        s.setFromMatrix4(c),
        a.copy(s).multiply(r);
      const h = a.elements;
      (n[v.CovarianceSizeFloats * e] = h[0] * h[0] + h[3] * h[3] + h[6] * h[6]),
        (n[v.CovarianceSizeFloats * e + 1] =
          h[0] * h[1] + h[3] * h[4] + h[6] * h[7]),
        (n[v.CovarianceSizeFloats * e + 2] =
          h[0] * h[2] + h[3] * h[5] + h[6] * h[8]),
        (n[v.CovarianceSizeFloats * e + 3] =
          h[1] * h[1] + h[4] * h[4] + h[7] * h[7]),
        (n[v.CovarianceSizeFloats * e + 4] =
          h[1] * h[2] + h[4] * h[5] + h[7] * h[8]),
        (n[v.CovarianceSizeFloats * e + 5] =
          h[2] * h[2] + h[5] * h[5] + h[8] * h[8]);
    }
  }
  getHeaderBufferData() {
    return this.headerBufferData;
  }
  getSplatBufferData() {
    return this.splatBufferData;
  }
  getPosition(t, n = new e.Vector3()) {
    let o = [0, 0, 0];
    const i = t * v.PositionComponentCount;
    if (this.compressionLevel > 0) {
      const e = this.compressionScaleFactor,
        s = this.compressionScaleRange,
        r = Math.floor(t / this.bucketSize);
      (o = new Float32Array(
        this.splatBufferData,
        this.bucketsBase + r * this.bytesPerBucket,
        3
      )),
        (n.x = (this.positionArray[i] - s) * e + o[0]),
        (n.y = (this.positionArray[i + 1] - s) * e + o[1]),
        (n.z = (this.positionArray[i + 2] - s) * e + o[2]);
    } else
      (n.x = this.positionArray[i]),
        (n.y = this.positionArray[i + 1]),
        (n.z = this.positionArray[i + 2]);
    return n;
  }
  setPosition(e, t) {
    let n = [0, 0, 0];
    const o = e * v.PositionComponentCount;
    if (this.compressionLevel > 0) {
      const i = 1 / this.compressionScaleFactor,
        s = this.compressionScaleRange,
        r = 2 * s + 1,
        a = Math.floor(e / this.bucketSize);
      (n = new Float32Array(
        this.splatBufferData,
        this.bucketsBase + a * this.bytesPerBucket,
        3
      )),
        (this.positionArray[o] = clamp(Math.round((t.x - n[0]) * i) + s, 0, r)),
        (this.positionArray[o + 1] = clamp(
          Math.round((t.y - n[1]) * i) + s,
          0,
          r
        )),
        (this.positionArray[o + 2] = clamp(
          Math.round((t.z - n[2]) * i) + s,
          0,
          r
        ));
    } else
      (this.positionArray[o] = t.x),
        (this.positionArray[o + 1] = t.y),
        (this.positionArray[o + 2] = t.z);
  }
  getScale(t, n = new e.Vector3()) {
    const o = t * v.ScaleComponentCount;
    return (
      n.set(
        g(this.scaleArray[o]),
        g(this.scaleArray[o + 1]),
        g(this.scaleArray[o + 2])
      ),
      n
    );
  }
  setScale(e, t) {
    const n = e * v.ScaleComponentCount;
    (this.scaleArray[n] = C(t.x)),
      (this.scaleArray[n + 1] = C(t.y)),
      (this.scaleArray[n + 2] = C(t.z));
  }
  getRotation(t, n = new e.Quaternion()) {
    const o = t * v.RotationComponentCount;
    return (
      n.set(
        g(this.rotationArray[o + 1]),
        g(this.rotationArray[o + 2]),
        g(this.rotationArray[o + 3]),
        g(this.rotationArray[o])
      ),
      n
    );
  }
  setRotation(e, t) {
    const n = e * v.RotationComponentCount;
    (this.rotationArray[n] = C(t.w)),
      (this.rotationArray[n + 1] = C(t.x)),
      (this.rotationArray[n + 2] = C(t.y)),
      (this.rotationArray[n + 3] = C(t.z));
  }
  getColor(t, n = new e.Vector4()) {
    const o = t * v.ColorComponentCount;
    return (
      n.set(
        this.colorArray[o],
        this.colorArray[o + 1],
        this.colorArray[o + 2],
        this.colorArray[o + 3]
      ),
      n
    );
  }
  setColor(e, t) {
    const n = e * v.ColorComponentCount;
    (this.colorArray[n] = t.x),
      (this.colorArray[n + 1] = t.y),
      (this.colorArray[n + 2] = t.z),
      (this.colorArray[n + 3] = t.w);
  }
  getPrecomputedCovarianceBufferData() {
    return this.precomputedCovarianceBufferData;
  }
  getSplatCount() {
    return this.splatCount;
  }
  fillPositionArray(e) {
    const t = this.splatCount;
    let n = [0, 0, 0];
    for (let o = 0; o < t; o++) {
      const t = o * v.PositionComponentCount;
      if (this.compressionLevel > 0) {
        const i = Math.floor(o / this.bucketSize);
        n = new Float32Array(
          this.splatBufferData,
          this.bucketsBase + i * this.bytesPerBucket,
          3
        );
        const s = this.compressionScaleFactor,
          r = this.compressionScaleRange;
        (e[t] = (this.positionArray[t] - r) * s + n[0]),
          (e[t + 1] = (this.positionArray[t + 1] - r) * s + n[1]),
          (e[t + 2] = (this.positionArray[t + 2] - r) * s + n[2]);
      } else
        (e[t] = this.positionArray[t]),
          (e[t + 1] = this.positionArray[t + 1]),
          (e[t + 2] = this.positionArray[t + 2]);
    }
  }
  fillScaleArray(e) {
    const t = this.fbf.bind(this),
      n = this.splatCount;
    for (let o = 0; o < n; o++) {
      const n = o * v.ScaleComponentCount;
      (e[n] = t(this.scaleArray[n])),
        (e[n + 1] = t(this.scaleArray[n + 1])),
        (e[n + 2] = t(this.scaleArray[n + 2]));
    }
  }
  fillRotationArray(e) {
    const t = this.fbf.bind(this),
      n = this.splatCount;
    for (let o = 0; o < n; o++) {
      const n = o * v.RotationComponentCount;
      (e[n] = t(this.rotationArray[n])),
        (e[n + 1] = t(this.rotationArray[n + 1])),
        (e[n + 2] = t(this.rotationArray[n + 2])),
        (e[n + 3] = t(this.rotationArray[n + 3]));
    }
  }
  fillColorArray(e) {
    const t = this.splatCount;
    for (let n = 0; n < t; n++) {
      const t = n * v.ColorComponentCount;
      (e[t] = this.colorArray[t]),
        (e[t + 1] = this.colorArray[t + 1]),
        (e[t + 2] = this.colorArray[t + 2]),
        (e[t + 3] = this.colorArray[t + 3]);
    }
  }
  swapVertices(e, t) {
    this.getPosition(e, p),
      this.getPosition(t, u),
      this.setPosition(t, p),
      this.setPosition(e, u),
      this.getScale(e, p),
      this.getScale(t, u),
      this.setScale(t, p),
      this.setScale(e, u),
      this.getRotation(e, f),
      this.getRotation(t, y),
      this.setRotation(t, f),
      this.setRotation(e, y),
      this.getColor(e, d),
      this.getColor(t, m),
      this.setColor(t, d),
      this.setColor(e, m);
  }
}
!(function () {
  const e = new Float32Array(1),
    t = new Int32Array(e.buffer);
})();
const w = (function () {
    const e = new Float32Array(1),
      t = new Int32Array(e.buffer);
    return function (n) {
      return (e[0] = n), t[0];
    };
  })(),
  x = function (e, t) {
    return new Promise((n, o) => {
      fetch(e).then(async (e) => {
        const i = e.body.getReader();
        let s = 0,
          r = e.headers.get("Content-Length"),
          a = r ? parseInt(r) : void 0;
        const c = [];
        for (;;)
          try {
            const { value: e, done: o } = await i.read();
            if (o) {
              t && t(100, "100%", e);
              const o = new Blob(c).arrayBuffer();
              n(o);
              break;
            }
            let r, l;
            (s += e.length),
              void 0 !== a && ((r = (s / a) * 100), (l = `${r.toFixed(2)}%`)),
              c.push(e),
              t && t(r, l, e);
          } catch (e) {
            o(e);
            break;
          }
      });
    });
  },
  A = function (e, t, n) {
    return Math.max(Math.min(e, n), t);
  },
  b = function () {
    return performance.now() / 1e3;
  },
  M = 256;
class P {
  constructor(e) {
    this.plyBuffer = e;
  }
  decodeHeader(e) {
    const t = new TextDecoder();
    let n = 0,
      o = "";
    console.log(".PLY size: " + e.byteLength + " bytes");
    const i = 100;
    for (;;) {
      if (n + i >= e.byteLength)
        throw new Error(
          "End of file reached while searching for end of header"
        );
      const s = new Uint8Array(e, n, i);
      (o += t.decode(s)), (n += i);
      const r = new Uint8Array(e, Math.max(0, n - 200), 200);
      if (t.decode(r).includes("end_header")) break;
    }
    const s = o.split("\n");
    let r = 0,
      a = {};
    for (let e = 0; e < s.length; e++) {
      const t = s[e].trim();
      if (t.startsWith("element vertex")) {
        const e = t.match(/\d+/);
        e && (r = parseInt(e[0]));
      } else if (t.startsWith("property")) {
        const e = t.match(/(\w+)\s+(\w+)\s+(\w+)/);
        if (e) {
          const t = e[2];
          a[e[3]] = t;
        }
      } else if ("end_header" === t) break;
    }
    const c = o.indexOf("end_header") + 10 + 1;
    return {
      splatCount: r,
      propertyTypes: a,
      vertexData: new DataView(e, c),
      headerOffset: n,
    };
  }
  readRawVertexFast(e, t, n, o, i, s) {
    let r = s || {};
    for (let s of o) {
      const o = i[s];
      "float" === o
        ? (r[s] = e.getFloat32(t + n[s], !0))
        : "uchar" === o && (r[s] = e.getUint8(t + n[s]) / 255);
    }
  }
  parseToSplatBuffer(t = 0, n = 1) {
    const o = performance.now();
    console.log("Parsing PLY to SPLAT...");
    const {
      splatCount: i,
      propertyTypes: s,
      vertexData: r,
    } = this.decodeHeader(this.plyBuffer);
    let a = 0;
    for (const e in s) e.startsWith("f_rest_") && (a += 1);
    const c = a / 3;
    console.log("Detected degree", 0, "with ", c, "coefficients per color");
    const l = [];
    for (let e = 0; e < 3; ++e) l.push(`f_dc_${e}`);
    for (let e = 0; e < c; ++e)
      for (let t = 0; t < 3; ++t) l.push(`f_rest_${t * c + e}`);
    let h = 0,
      p = {};
    const u = {
      double: 8,
      int: 4,
      uint: 4,
      float: 4,
      short: 2,
      ushort: 2,
      uchar: 1,
    };
    for (let e in s)
      if (s.hasOwnProperty(e)) {
        const t = s[e];
        (p[e] = h), (h += u[t]);
      }
    let d = {};
    const m = [
        "scale_0",
        "scale_1",
        "scale_2",
        "rot_0",
        "rot_1",
        "rot_2",
        "rot_3",
        "x",
        "y",
        "z",
        "f_dc_0",
        "f_dc_1",
        "f_dc_2",
        "opacity",
      ],
      f = [],
      y = {};
    for (let e of m) y[e] = 0;
    f.push(y);
    for (let e = 0; e < i; e++) {
      let t;
      if (
        (this.readRawVertexFast(r, e * h, p, m, s, d),
        (t = s.opacity ? (1 / (1 + Math.exp(-d.opacity))) * 255 : 255),
        t > n)
      ) {
        const e = {};
        for (let t of m) e[t] = d[t];
        f.push(e);
      }
    }
    console.log("Total valid splats: ", f.length, "out of", i);
    const g = [];
    for (let e = 0; e < f.length; e++) (d = f[e]), g.push([d.x, d.y, d.z]);
    const C = this.computeBuckets(g),
      w = C.length * M,
      x = v.HeaderSizeBytes,
      b = new Uint8Array(new ArrayBuffer(x));
    (b[3] = t), (new Uint32Array(b.buffer, 4, 1)[0] = w);
    let P = v.CompressionLevels[t].BytesPerPosition,
      S = v.CompressionLevels[t].BytesPerScale,
      D = v.CompressionLevels[t].BytesPerColor,
      T = v.CompressionLevels[t].BytesPerRotation;
    const B = new ArrayBuffer(P * w),
      z = new ArrayBuffer(S * w),
      F = new ArrayBuffer(D * w),
      E = new ArrayBuffer(T * w),
      R = v.CompressionLevels[t].ScaleRange,
      I = R / 2.5,
      L = 2 * R + 1,
      V = new e.Vector3(),
      k = new e.Vector3();
    let U = 0;
    for (let n = 0; n < C.length; n++) {
      const o = C[n];
      V.fromArray(o.center);
      for (let n = 0; n < o.splats.length; n++) {
        let i = o.splats[n],
          r = !1;
        if ((0 === i && (r = !0), (d = f[i]), 0 === t)) {
          const t = new Float32Array(B, U * P, 3),
            n = new Float32Array(z, U * S, 3),
            o = new Float32Array(E, U * T, 4);
          if (s.scale_0) {
            const t = new e.Quaternion(d.rot_1, d.rot_2, d.rot_3, d.rot_0);
            t.normalize(),
              o.set([t.w, t.x, t.y, t.z]),
              n.set([
                Math.exp(d.scale_0),
                Math.exp(d.scale_1),
                Math.exp(d.scale_2),
              ]);
          } else n.set([0.01, 0.01, 0.01]), o.set([1, 0, 0, 0]);
          t.set([d.x, d.y, d.z]);
        } else {
          const t = new Uint16Array(B, U * P, 3),
            n = new Uint16Array(z, U * S, 3),
            o = new Uint16Array(E, U * T, 4),
            i = e.DataUtils.toHalfFloat.bind(e.DataUtils);
          if (s.scale_0) {
            const t = new e.Quaternion(d.rot_1, d.rot_2, d.rot_3, d.rot_0);
            t.normalize(),
              o.set([i(t.w), i(t.x), i(t.y), i(t.z)]),
              n.set([
                i(Math.exp(d.scale_0)),
                i(Math.exp(d.scale_1)),
                i(Math.exp(d.scale_2)),
              ]);
          } else n.set([i(0.01), i(0.01), i(0.01)]), o.set([i(1), 0, 0, 0]);
          k.set(d.x, d.y, d.z).sub(V),
            (k.x = Math.round(k.x * I) + R),
            (k.x = A(k.x, 0, L)),
            (k.y = Math.round(k.y * I) + R),
            (k.y = A(k.y, 0, L)),
            (k.z = Math.round(k.z * I) + R),
            (k.z = A(k.z, 0, L)),
            t.set([k.x, k.y, k.z]);
        }
        const a = new Uint8ClampedArray(F, U * D, 4);
        if (r) (a[0] = 255), (a[1] = 0), (a[2] = 0), (a[3] = 0);
        else {
          if (s.f_dc_0) {
            const e = 0.28209479177387814;
            a.set([
              255 * (0.5 + e * d.f_dc_0),
              255 * (0.5 + e * d.f_dc_1),
              255 * (0.5 + e * d.f_dc_2),
            ]);
          } else a.set([255, 0, 0]);
          s.opacity
            ? (a[3] = (1 / (1 + Math.exp(-d.opacity))) * 255)
            : (a[3] = 255);
        }
        U++;
      }
    }
    const _ = 12 * C.length,
      O = B.byteLength + z.byteLength + F.byteLength + E.byteLength,
      N = new Uint32Array(b.buffer),
      j = new Float32Array(b.buffer);
    let H = x + O;
    t > 0 &&
      ((H += _),
      (N[2] = M),
      (N[3] = C.length),
      (j[4] = 5),
      (N[5] = 12),
      (N[6] = v.CompressionLevels[t].ScaleRange));
    const W = new ArrayBuffer(H);
    if (
      (new Uint8Array(W, 0, x).set(b),
      new Uint8Array(W, x, B.byteLength).set(new Uint8Array(B)),
      new Uint8Array(W, x + B.byteLength, z.byteLength).set(new Uint8Array(z)),
      new Uint8Array(W, x + B.byteLength + z.byteLength, F.byteLength).set(
        new Uint8Array(F)
      ),
      new Uint8Array(
        W,
        x + B.byteLength + z.byteLength + F.byteLength,
        E.byteLength
      ).set(new Uint8Array(E)),
      t > 0)
    ) {
      const e = new Float32Array(W, x + O, 3 * C.length);
      for (let t = 0; t < C.length; t++) {
        const n = C[t],
          o = 3 * t;
        (e[o] = n.center[0]),
          (e[o + 1] = n.center[1]),
          (e[o + 2] = n.center[2]);
      }
    }
    const Y = new v(W),
      G = performance.now();
    return (
      console.log("Parsing PLY to SPLAT complete!"),
      console.log("Total time: ", (G - o).toFixed(2) + " ms"),
      Y
    );
  }
  computeBuckets(t) {
    const n = t.length,
      o = new e.Vector3(),
      i = new e.Vector3();
    for (let e = 1; e < n; e++) {
      const n = t[e];
      (0 === e || n[0] < o.x) && (o.x = n[0]),
        (0 === e || n[0] > i.x) && (i.x = n[0]),
        (0 === e || n[1] < o.y) && (o.y = n[1]),
        (0 === e || n[1] > i.y) && (i.y = n[1]),
        (0 === e || n[2] < o.z) && (o.z = n[2]),
        (0 === e || n[2] > i.z) && (i.z = n[2]);
    }
    const s = new e.Vector3().copy(i).sub(o),
      r = Math.ceil(s.y / 5),
      a = Math.ceil(s.z / 5),
      c = new e.Vector3(),
      l = [],
      h = {};
    for (let e = 1; e < n; e++) {
      const n = t[e],
        i = Math.ceil((n[0] - o.x) / 5),
        s = Math.ceil((n[1] - o.y) / 5),
        p = Math.ceil((n[2] - o.z) / 5);
      (c.x = 5 * (i - 1) + o.x + 2.5),
        (c.y = 5 * (s - 1) + o.y + 2.5),
        (c.z = 5 * (p - 1) + o.z + 2.5);
      const u = i * (r * a) + s * a + p;
      let d = h[u];
      d || (h[u] = d = { splats: [], center: c.toArray() }),
        d.splats.push(e),
        d.splats.length >= M && (l.push(d), (h[u] = null));
    }
    for (let e in h)
      if (h.hasOwnProperty(e)) {
        const t = h[e];
        if (t) {
          for (; t.splats.length < M; ) t.splats.push(0);
          l.push(t);
        }
      }
    return l;
  }
}
class S {
  constructor() {
    this.splatBuffer = null;
  }
  fetchFile(e, t) {
    return new Promise((n, o) => {
      x(e, t)
        .then((e) => {
          n(e);
        })
        .catch((e) => {
          o(e);
        });
    });
  }
  loadFromURL(e, t = 0, n = 1) {
    return new Promise((o, i) => {
      this.fetchFile(e)
        .then((e) => {
          const i = new P(e).parseToSplatBuffer(t, n);
          (this.splatBuffer = i), o(i);
        })
        .catch((e) => {
          i(e);
        });
    });
  }
}
class D {
  constructor(e = null) {
    (this.splatBuffer = e), (this.downLoadLink = null);
  }
  loadFromURL(e, t) {
    return new Promise((n, o) => {
      x(e, t)
        .then((e) => {
          const t = new v(e);
          n(t);
        })
        .catch((e) => {
          o(e);
        });
    });
  }
  setFromBuffer(e) {
    this.splatBuffer = e;
  }
  downloadFile(e) {
    const t = new Uint8Array(this.splatBuffer.getHeaderBufferData()),
      n = new Uint8Array(this.splatBuffer.getSplatBufferData()),
      o = new Blob([t.buffer, n.buffer], { type: "application/octet-stream" });
    this.downLoadLink ||
      ((this.downLoadLink = document.createElement("a")),
      document.body.appendChild(this.downLoadLink)),
      (this.downLoadLink.download = e),
      (this.downLoadLink.href = URL.createObjectURL(o)),
      this.downLoadLink.click();
  }
}
const T = { type: "change" },
  B = { type: "start" },
  z = { type: "end" },
  F = new t(),
  E = new n(),
  R = Math.cos(70 * o.DEG2RAD);
class I extends i {
  constructor(e, t) {
    super(),
      (this.object = e),
      (this.domElement = t),
      (this.domElement.style.touchAction = "none"),
      (this.enabled = !0),
      (this.target = new s()),
      (this.minDistance = 0),
      (this.maxDistance = 1 / 0),
      (this.minZoom = 0),
      (this.maxZoom = 1 / 0),
      (this.minPolarAngle = 0),
      (this.maxPolarAngle = Math.PI),
      (this.minAzimuthAngle = -1 / 0),
      (this.maxAzimuthAngle = 1 / 0),
      (this.enableDamping = !1),
      (this.dampingFactor = 0.05),
      (this.enableZoom = !0),
      (this.zoomSpeed = 1),
      (this.enableRotate = !0),
      (this.rotateSpeed = 1),
      (this.enablePan = !0),
      (this.panSpeed = 1),
      (this.screenSpacePanning = !0),
      (this.keyPanSpeed = 7),
      (this.zoomToCursor = !1),
      (this.autoRotate = !1),
      (this.autoRotateSpeed = 2),
      (this.keys = { LEFT: "KeyA", UP: "KeyW", RIGHT: "KeyD", BOTTOM: "KeyS" }),
      (this.mouseButtons = { LEFT: r.ROTATE, MIDDLE: r.DOLLY, RIGHT: r.PAN }),
      (this.touches = { ONE: a.ROTATE, TWO: a.DOLLY_PAN }),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this._domElementKeyEvents = null),
      (this.getPolarAngle = function () {
        return u.phi;
      }),
      (this.getAzimuthalAngle = function () {
        return u.theta;
      }),
      (this.getDistance = function () {
        return this.object.position.distanceTo(this.target);
      }),
      (this.listenToKeyEvents = function (e) {
        e.addEventListener("keydown", ie), (this._domElementKeyEvents = e);
      }),
      (this.stopListenToKeyEvents = function () {
        this._domElementKeyEvents.removeEventListener("keydown", ie),
          (this._domElementKeyEvents = null);
      }),
      (this.saveState = function () {
        n.target0.copy(n.target),
          n.position0.copy(n.object.position),
          (n.zoom0 = n.object.zoom);
      }),
      (this.reset = function () {
        n.target.copy(n.target0),
          n.object.position.copy(n.position0),
          (n.object.zoom = n.zoom0),
          n.object.updateProjectionMatrix(),
          n.dispatchEvent(T),
          n.update(),
          (i = o.NONE);
      }),
      (this.update = (function () {
        const t = new s(),
          r = new c().setFromUnitVectors(e.up, new s(0, 1, 0)),
          a = r.clone().invert(),
          l = new s(),
          h = new c(),
          y = new s(),
          g = 2 * Math.PI;
        return function () {
          r.setFromUnitVectors(e.up, new s(0, 1, 0)), a.copy(r).invert();
          const c = n.object.position;
          t.copy(c).sub(n.target),
            t.applyQuaternion(r),
            u.setFromVector3(t),
            n.autoRotate &&
              i === o.NONE &&
              k(((2 * Math.PI) / 60 / 60) * n.autoRotateSpeed),
            n.enableDamping
              ? ((u.theta += d.theta * n.dampingFactor),
                (u.phi += d.phi * n.dampingFactor))
              : ((u.theta += d.theta), (u.phi += d.phi));
          let C = n.minAzimuthAngle,
            v = n.maxAzimuthAngle;
          isFinite(C) &&
            isFinite(v) &&
            (C < -Math.PI ? (C += g) : C > Math.PI && (C -= g),
            v < -Math.PI ? (v += g) : v > Math.PI && (v -= g),
            (u.theta =
              C <= v
                ? Math.max(C, Math.min(v, u.theta))
                : u.theta > (C + v) / 2
                ? Math.max(C, u.theta)
                : Math.min(v, u.theta))),
            (u.phi = Math.max(
              n.minPolarAngle,
              Math.min(n.maxPolarAngle, u.phi)
            )),
            u.makeSafe(),
            !0 === n.enableDamping
              ? n.target.addScaledVector(f, n.dampingFactor)
              : n.target.add(f),
            (n.zoomToCursor && D) || n.object.isOrthographicCamera
              ? (u.radius = Y(u.radius))
              : (u.radius = Y(u.radius * m)),
            t.setFromSpherical(u),
            t.applyQuaternion(a),
            c.copy(n.target).add(t),
            n.object.lookAt(n.target),
            !0 === n.enableDamping
              ? ((d.theta *= 1 - n.dampingFactor),
                (d.phi *= 1 - n.dampingFactor),
                f.multiplyScalar(1 - n.dampingFactor))
              : (d.set(0, 0, 0), f.set(0, 0, 0));
          let w = !1;
          if (n.zoomToCursor && D) {
            let o = null;
            if (n.object.isPerspectiveCamera) {
              const e = t.length();
              o = Y(e * m);
              const i = e - o;
              n.object.position.addScaledVector(P, i),
                n.object.updateMatrixWorld();
            } else if (n.object.isOrthographicCamera) {
              const e = new s(S.x, S.y, 0);
              e.unproject(n.object),
                (n.object.zoom = Math.max(
                  n.minZoom,
                  Math.min(n.maxZoom, n.object.zoom / m)
                )),
                n.object.updateProjectionMatrix(),
                (w = !0);
              const i = new s(S.x, S.y, 0);
              i.unproject(n.object),
                n.object.position.sub(i).add(e),
                n.object.updateMatrixWorld(),
                (o = t.length());
            } else
              console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."
              ),
                (n.zoomToCursor = !1);
            null !== o &&
              (this.screenSpacePanning
                ? n.target
                    .set(0, 0, -1)
                    .transformDirection(n.object.matrix)
                    .multiplyScalar(o)
                    .add(n.object.position)
                : (F.origin.copy(n.object.position),
                  F.direction.set(0, 0, -1).transformDirection(n.object.matrix),
                  Math.abs(n.object.up.dot(F.direction)) < R
                    ? e.lookAt(n.target)
                    : (E.setFromNormalAndCoplanarPoint(n.object.up, n.target),
                      F.intersectPlane(E, n.target))));
          } else
            n.object.isOrthographicCamera &&
              ((n.object.zoom = Math.max(
                n.minZoom,
                Math.min(n.maxZoom, n.object.zoom / m)
              )),
              n.object.updateProjectionMatrix(),
              (w = !0));
          return (
            (m = 1),
            (D = !1),
            !!(
              w ||
              l.distanceToSquared(n.object.position) > p ||
              8 * (1 - h.dot(n.object.quaternion)) > p ||
              y.distanceToSquared(n.target) > 0
            ) &&
              (n.dispatchEvent(T),
              l.copy(n.object.position),
              h.copy(n.object.quaternion),
              y.copy(n.target),
              (w = !1),
              !0)
          );
        };
      })()),
      (this.dispose = function () {
        n.domElement.removeEventListener("contextmenu", se),
          n.domElement.removeEventListener("pointerdown", ee),
          n.domElement.removeEventListener("pointercancel", ne),
          n.domElement.removeEventListener("wheel", oe),
          n.domElement.removeEventListener("pointermove", te),
          n.domElement.removeEventListener("pointerup", ne),
          null !== n._domElementKeyEvents &&
            (n._domElementKeyEvents.removeEventListener("keydown", ie),
            (n._domElementKeyEvents = null));
      });
    const n = this,
      o = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let i = o.NONE;
    const p = 1e-6,
      u = new l(),
      d = new l();
    let m = 1;
    const f = new s(),
      y = new h(),
      g = new h(),
      C = new h(),
      v = new h(),
      w = new h(),
      x = new h(),
      A = new h(),
      b = new h(),
      M = new h(),
      P = new s(),
      S = new h();
    let D = !1;
    const I = [],
      L = {};
    function V() {
      return Math.pow(0.95, n.zoomSpeed);
    }
    function k(e) {
      d.theta -= e;
    }
    function U(e) {
      d.phi -= e;
    }
    const _ = (function () {
        const e = new s();
        return function (t, n) {
          e.setFromMatrixColumn(n, 0), e.multiplyScalar(-t), f.add(e);
        };
      })(),
      O = (function () {
        const e = new s();
        return function (t, o) {
          !0 === n.screenSpacePanning
            ? e.setFromMatrixColumn(o, 1)
            : (e.setFromMatrixColumn(o, 0), e.crossVectors(n.object.up, e)),
            e.multiplyScalar(t),
            f.add(e);
        };
      })(),
      N = (function () {
        const e = new s();
        return function (t, o) {
          const i = n.domElement;
          if (n.object.isPerspectiveCamera) {
            const s = n.object.position;
            e.copy(s).sub(n.target);
            let r = e.length();
            (r *= Math.tan(((n.object.fov / 2) * Math.PI) / 180)),
              _((2 * t * r) / i.clientHeight, n.object.matrix),
              O((2 * o * r) / i.clientHeight, n.object.matrix);
          } else
            n.object.isOrthographicCamera
              ? (_(
                  (t * (n.object.right - n.object.left)) /
                    n.object.zoom /
                    i.clientWidth,
                  n.object.matrix
                ),
                O(
                  (o * (n.object.top - n.object.bottom)) /
                    n.object.zoom /
                    i.clientHeight,
                  n.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (n.enablePan = !1));
        };
      })();
    function j(e) {
      n.object.isPerspectiveCamera || n.object.isOrthographicCamera
        ? (m /= e)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (n.enableZoom = !1));
    }
    function H(e) {
      n.object.isPerspectiveCamera || n.object.isOrthographicCamera
        ? (m *= e)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (n.enableZoom = !1));
    }
    function W(t) {
      if (!n.zoomToCursor) return;
      D = !0;
      const o = n.domElement.getBoundingClientRect(),
        i = t.clientX - o.left,
        s = t.clientY - o.top,
        r = o.width,
        a = o.height;
      (S.x = (i / r) * 2 - 1),
        (S.y = (-s / a) * 2 + 1),
        P.set(S.x, S.y, 1).unproject(e).sub(e.position).normalize();
    }
    function Y(e) {
      return Math.max(n.minDistance, Math.min(n.maxDistance, e));
    }
    function G(e) {
      y.set(e.clientX, e.clientY);
    }
    function Q(e) {
      v.set(e.clientX, e.clientY);
    }
    function K() {
      if (1 === I.length) y.set(I[0].pageX, I[0].pageY);
      else {
        const e = 0.5 * (I[0].pageX + I[1].pageX),
          t = 0.5 * (I[0].pageY + I[1].pageY);
        y.set(e, t);
      }
    }
    function X() {
      if (1 === I.length) v.set(I[0].pageX, I[0].pageY);
      else {
        const e = 0.5 * (I[0].pageX + I[1].pageX),
          t = 0.5 * (I[0].pageY + I[1].pageY);
        v.set(e, t);
      }
    }
    function $() {
      const e = I[0].pageX - I[1].pageX,
        t = I[0].pageY - I[1].pageY,
        n = Math.sqrt(e * e + t * t);
      A.set(0, n);
    }
    function Z(e) {
      if (1 == I.length) g.set(e.pageX, e.pageY);
      else {
        const t = ae(e),
          n = 0.5 * (e.pageX + t.x),
          o = 0.5 * (e.pageY + t.y);
        g.set(n, o);
      }
      C.subVectors(g, y).multiplyScalar(n.rotateSpeed);
      const t = n.domElement;
      k((2 * Math.PI * C.x) / t.clientHeight),
        U((2 * Math.PI * C.y) / t.clientHeight),
        y.copy(g);
    }
    function q(e) {
      if (1 === I.length) w.set(e.pageX, e.pageY);
      else {
        const t = ae(e),
          n = 0.5 * (e.pageX + t.x),
          o = 0.5 * (e.pageY + t.y);
        w.set(n, o);
      }
      x.subVectors(w, v).multiplyScalar(n.panSpeed), N(x.x, x.y), v.copy(w);
    }
    function J(e) {
      const t = ae(e),
        o = e.pageX - t.x,
        i = e.pageY - t.y,
        s = Math.sqrt(o * o + i * i);
      b.set(0, s),
        M.set(0, Math.pow(b.y / A.y, n.zoomSpeed)),
        j(M.y),
        A.copy(b);
    }
    function ee(e) {
      !1 !== n.enabled &&
        (0 === I.length &&
          (n.domElement.setPointerCapture(e.pointerId),
          n.domElement.addEventListener("pointermove", te),
          n.domElement.addEventListener("pointerup", ne)),
        (function (e) {
          I.push(e);
        })(e),
        "touch" === e.pointerType
          ? (function (e) {
              switch ((re(e), I.length)) {
                case 1:
                  switch (n.touches.ONE) {
                    case a.ROTATE:
                      if (!1 === n.enableRotate) return;
                      K(), (i = o.TOUCH_ROTATE);
                      break;
                    case a.PAN:
                      if (!1 === n.enablePan) return;
                      X(), (i = o.TOUCH_PAN);
                      break;
                    default:
                      i = o.NONE;
                  }
                  break;
                case 2:
                  switch (n.touches.TWO) {
                    case a.DOLLY_PAN:
                      if (!1 === n.enableZoom && !1 === n.enablePan) return;
                      n.enableZoom && $(),
                        n.enablePan && X(),
                        (i = o.TOUCH_DOLLY_PAN);
                      break;
                    case a.DOLLY_ROTATE:
                      if (!1 === n.enableZoom && !1 === n.enableRotate) return;
                      n.enableZoom && $(),
                        n.enableRotate && K(),
                        (i = o.TOUCH_DOLLY_ROTATE);
                      break;
                    default:
                      i = o.NONE;
                  }
                  break;
                default:
                  i = o.NONE;
              }
              i !== o.NONE && n.dispatchEvent(B);
            })(e)
          : (function (e) {
              let t;
              switch (e.button) {
                case 0:
                  t = n.mouseButtons.LEFT;
                  break;
                case 1:
                  t = n.mouseButtons.MIDDLE;
                  break;
                case 2:
                  t = n.mouseButtons.RIGHT;
                  break;
                default:
                  t = -1;
              }
              switch (t) {
                case r.DOLLY:
                  if (!1 === n.enableZoom) return;
                  !(function (e) {
                    W(e), A.set(e.clientX, e.clientY);
                  })(e),
                    (i = o.DOLLY);
                  break;
                case r.ROTATE:
                  if (e.ctrlKey || e.metaKey || e.shiftKey) {
                    if (!1 === n.enablePan) return;
                    Q(e), (i = o.PAN);
                  } else {
                    if (!1 === n.enableRotate) return;
                    G(e), (i = o.ROTATE);
                  }
                  break;
                case r.PAN:
                  if (e.ctrlKey || e.metaKey || e.shiftKey) {
                    if (!1 === n.enableRotate) return;
                    G(e), (i = o.ROTATE);
                  } else {
                    if (!1 === n.enablePan) return;
                    Q(e), (i = o.PAN);
                  }
                  break;
                default:
                  i = o.NONE;
              }
              i !== o.NONE && n.dispatchEvent(B);
            })(e));
    }
    function te(e) {
      !1 !== n.enabled &&
        ("touch" === e.pointerType
          ? (function (e) {
              switch ((re(e), i)) {
                case o.TOUCH_ROTATE:
                  if (!1 === n.enableRotate) return;
                  Z(e), n.update();
                  break;
                case o.TOUCH_PAN:
                  if (!1 === n.enablePan) return;
                  q(e), n.update();
                  break;
                case o.TOUCH_DOLLY_PAN:
                  if (!1 === n.enableZoom && !1 === n.enablePan) return;
                  !(function (e) {
                    n.enableZoom && J(e), n.enablePan && q(e);
                  })(e),
                    n.update();
                  break;
                case o.TOUCH_DOLLY_ROTATE:
                  if (!1 === n.enableZoom && !1 === n.enableRotate) return;
                  !(function (e) {
                    n.enableZoom && J(e), n.enableRotate && Z(e);
                  })(e),
                    n.update();
                  break;
                default:
                  i = o.NONE;
              }
            })(e)
          : (function (e) {
              switch (i) {
                case o.ROTATE:
                  if (!1 === n.enableRotate) return;
                  !(function (e) {
                    g.set(e.clientX, e.clientY),
                      C.subVectors(g, y).multiplyScalar(n.rotateSpeed);
                    const t = n.domElement;
                    k((2 * Math.PI * C.x) / t.clientHeight),
                      U((2 * Math.PI * C.y) / t.clientHeight),
                      y.copy(g),
                      n.update();
                  })(e);
                  break;
                case o.DOLLY:
                  if (!1 === n.enableZoom) return;
                  !(function (e) {
                    b.set(e.clientX, e.clientY),
                      M.subVectors(b, A),
                      M.y > 0 ? j(V()) : M.y < 0 && H(V()),
                      A.copy(b),
                      n.update();
                  })(e);
                  break;
                case o.PAN:
                  if (!1 === n.enablePan) return;
                  !(function (e) {
                    w.set(e.clientX, e.clientY),
                      x.subVectors(w, v).multiplyScalar(n.panSpeed),
                      N(x.x, x.y),
                      v.copy(w),
                      n.update();
                  })(e);
              }
            })(e));
    }
    function ne(e) {
      !(function (e) {
        delete L[e.pointerId];
        for (let t = 0; t < I.length; t++)
          if (I[t].pointerId == e.pointerId) return void I.splice(t, 1);
      })(e),
        0 === I.length &&
          (n.domElement.releasePointerCapture(e.pointerId),
          n.domElement.removeEventListener("pointermove", te),
          n.domElement.removeEventListener("pointerup", ne)),
        n.dispatchEvent(z),
        (i = o.NONE);
    }
    function oe(e) {
      !1 !== n.enabled &&
        !1 !== n.enableZoom &&
        i === o.NONE &&
        (e.preventDefault(),
        n.dispatchEvent(B),
        (function (e) {
          W(e), e.deltaY < 0 ? H(V()) : e.deltaY > 0 && j(V()), n.update();
        })(e),
        n.dispatchEvent(z));
    }
    function ie(e) {
      !1 !== n.enabled &&
        !1 !== n.enablePan &&
        (function (e) {
          let t = !1;
          switch (e.code) {
            case n.keys.UP:
              e.ctrlKey || e.metaKey || e.shiftKey
                ? U((2 * Math.PI * n.rotateSpeed) / n.domElement.clientHeight)
                : N(0, n.keyPanSpeed),
                (t = !0);
              break;
            case n.keys.BOTTOM:
              e.ctrlKey || e.metaKey || e.shiftKey
                ? U((-2 * Math.PI * n.rotateSpeed) / n.domElement.clientHeight)
                : N(0, -n.keyPanSpeed),
                (t = !0);
              break;
            case n.keys.LEFT:
              e.ctrlKey || e.metaKey || e.shiftKey
                ? k((2 * Math.PI * n.rotateSpeed) / n.domElement.clientHeight)
                : N(n.keyPanSpeed, 0),
                (t = !0);
              break;
            case n.keys.RIGHT:
              e.ctrlKey || e.metaKey || e.shiftKey
                ? k((-2 * Math.PI * n.rotateSpeed) / n.domElement.clientHeight)
                : N(-n.keyPanSpeed, 0),
                (t = !0);
          }
          t && (e.preventDefault(), n.update());
        })(e);
    }
    function se(e) {
      !1 !== n.enabled && e.preventDefault();
    }
    function re(e) {
      let t = L[e.pointerId];
      void 0 === t && ((t = new h()), (L[e.pointerId] = t)),
        t.set(e.pageX, e.pageY);
    }
    function ae(e) {
      const t = e.pointerId === I[0].pointerId ? I[1] : I[0];
      return L[t.pointerId];
    }
    n.domElement.addEventListener("contextmenu", se),
      n.domElement.addEventListener("pointerdown", ee),
      n.domElement.addEventListener("pointercancel", ne),
      n.domElement.addEventListener("wheel", oe, { passive: !1 }),
      this.update();
  }
}
class L {
  constructor(e) {
    (this.message = e || "Loading..."),
      (this.spinnerDivContainer = document.createElement("div")),
      (this.spinnerDiv = document.createElement("div")),
      (this.messageDiv = document.createElement("div")),
      (this.spinnerDivContainer.className = "loaderContainer"),
      (this.spinnerDiv.className = "loader"),
      (this.spinnerDivContainer.style.display = "none"),
      (this.messageDiv.className = "message"),
      (this.messageDiv.innerHTML = this.message),
      this.spinnerDivContainer.appendChild(this.spinnerDiv),
      this.spinnerDivContainer.appendChild(this.messageDiv),
      document.body.appendChild(this.spinnerDivContainer);
    const t = document.createElement("style");
    (t.innerHTML =
      "\n\n            .message {\n                font-family: arial;\n                font-size: 12pt;\n                color: #ffffff;\n                text-align: center;\n                padding-top:15px;\n                width:180px;\n            }\n\n            .loaderContainer {\n                position: absolute;\n                top: 50%;\n                left: 50%;\n                transform: translate(-80px, -80px);\n                width: 180px;\n            }\n\n            .loader {\n                width: 120px;        /* the size */\n                padding: 15px;       /* the border thickness */\n                background: #07e8d6; /* the color */\n                z-index:99999;\n            \n                aspect-ratio: 1;\n                border-radius: 50%;\n                --_m: \n                    conic-gradient(#0000,#000),\n                    linear-gradient(#000 0 0) content-box;\n                -webkit-mask: var(--_m);\n                    mask: var(--_m);\n                -webkit-mask-composite: source-out;\n                    mask-composite: subtract;\n                box-sizing: border-box;\n                animation: load 1s linear infinite;\n                margin-left: 30px;\n            }\n            \n            @keyframes load {\n                to{transform: rotate(1turn)}\n            }\n\n        "),
      document.getElementsByTagName("head")[0].appendChild(t);
  }
  show() {
    this.spinnerDivContainer.style.display = "block";
  }
  hide() {
    this.spinnerDivContainer.style.display = "none";
  }
  setMessage(e) {
    this.messageDiv.innerHTML = e;
  }
}
class V extends e.Object3D {
  constructor(
    t = new e.Vector3(0, 0, 1),
    n = new e.Vector3(0, 0, 0),
    o = 1,
    i = 0.1,
    s = 16776960,
    r = 0.2 * o,
    a = 0.2 * r
  ) {
    super(), (this.type = "ArrowHelper");
    const c = new e.CylinderGeometry(i, i, o, 32);
    c.translate(0, o / 2, 0);
    const l = new e.CylinderGeometry(0, a, r, 32);
    l.translate(0, o, 0),
      this.position.copy(n),
      (this.line = new e.Mesh(
        c,
        new e.MeshBasicMaterial({ color: s, toneMapped: !1 })
      )),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new e.Mesh(
        l,
        new e.MeshBasicMaterial({ color: s, toneMapped: !1 })
      )),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(t);
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      _axis.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(_axis, t);
    }
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return (
      super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    );
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose();
  }
}
class k {
  constructor(e, t) {
    (this.scene = e),
      (this.simpleScene = t),
      (this.meshCursor = null),
      (this.focusMarker = null),
      (this.controlPlane = null);
  }
  setupMeshCursor() {
    if (!this.meshCursor) {
      const t = new e.ConeGeometry(0.5, 1.5, 32),
        n = new e.MeshBasicMaterial({ color: 16777215 }),
        o = new e.Mesh(t, n);
      o.rotation.set(0, 0, Math.PI), o.position.set(0, 1, 0);
      const i = new e.Mesh(t, n);
      i.position.set(0, -1, 0);
      const s = new e.Mesh(t, n);
      s.rotation.set(0, 0, Math.PI / 2), s.position.set(1, 0, 0);
      const r = new e.Mesh(t, n);
      r.rotation.set(0, 0, -Math.PI / 2),
        r.position.set(-1, 0, 0),
        (this.meshCursor = new e.Object3D()),
        this.meshCursor.add(o),
        this.meshCursor.add(i),
        this.meshCursor.add(s),
        this.meshCursor.add(r),
        this.meshCursor.scale.set(0.1, 0.1, 0.1),
        this.simpleScene.add(this.meshCursor),
        (this.meshCursor.visible = !1);
    }
  }
  destroyMeshCursor() {
    this.meshCursor &&
      (this.meshCursor.children.forEach((e) => {
        e.geometry.dispose(), e.material.dispose();
      }),
      this.simpleScene.remove(this.meshCursor),
      (this.meshCursor = null));
  }
  setMeshCursorVisibility(e) {
    this.meshCursor.visible = e;
  }
  setMeshCursorPosition(e) {
    this.meshCursor.position.copy(e);
  }
  positionAndOrientMeshCursor(e, t) {
    this.meshCursor.position.copy(e),
      this.meshCursor.up.copy(t.up),
      this.meshCursor.lookAt(t.position);
  }
  setupFocusMarker() {
    if (!this.focusMarker) {
      const t = new e.SphereGeometry(0.5, 32, 32),
        n = k.buildFocusMarkerMaterial();
      (n.depthTest = !1), (n.depthWrite = !1), (n.transparent = !0);
      const o = new e.Mesh(t, n);
      this.focusMarker = o;
    }
  }
  updateFocusMarker = (function () {
    const t = new e.Vector3(),
      n = new e.Matrix4();
    return function (e, o, i) {
      n.copy(o.matrixWorld).invert(),
        t.copy(e).applyMatrix4(n),
        t.normalize().multiplyScalar(10),
        t.applyMatrix4(o.matrixWorld),
        this.focusMarker.position.copy(t),
        this.focusMarker.material.uniforms.realFocusPosition.value.copy(e),
        this.focusMarker.material.uniforms.viewport.value.copy(i),
        (this.focusMarker.material.uniformsNeedUpdate = !0);
    };
  })();
  setFocusMarkerVisibility(e) {
    this.focusMarker.visible = e;
  }
  setFocusMarkerOpacity(e) {
    (this.focusMarker.material.uniforms.opacity.value = e),
      (this.focusMarker.material.uniformsNeedUpdate = !0);
  }
  getFocusMarkerOpacity() {
    return this.focusMarker.material.uniforms.opacity.value;
  }
  setupControlPlane() {
    const t = new e.PlaneGeometry(1, 1);
    t.rotateX(-Math.PI / 2);
    const n = new e.MeshBasicMaterial({ color: 16777215 });
    (n.transparent = !0),
      (n.opacity = 0.6),
      (n.depthTest = !1),
      (n.depthWrite = !1),
      (n.side = e.DoubleSide);
    const o = new e.Mesh(t, n),
      i = new e.Vector3(0, 1, 0);
    i.normalize();
    const s = new e.Vector3(0, 0, 0),
      r = new V(i, s, 0.5, 0.01, 56576, 0.1, 0.03);
    (this.controlPlane = new e.Object3D()),
      this.controlPlane.add(o),
      this.controlPlane.add(r);
  }
  setControlPlaneVisibility(e) {
    this.controlPlane.visible = e;
  }
  positionAndOrientControlPlane = (function () {
    const t = new e.Quaternion(),
      n = new e.Vector3(0, 1, 0);
    return function (e, o) {
      t.setFromUnitVectors(n, o),
        this.controlPlane.position.copy(e),
        this.controlPlane.quaternion.copy(t);
    };
  })();
  addDebugMeshes() {
    (this.debugRoot = this.createDebugMeshes()),
      (this.secondaryDebugRoot = this.createSecondaryDebugMeshes()),
      this.simpleScene.add(this.debugRoot),
      this.simpleScene.add(this.secondaryDebugRoot);
  }
  createDebugMeshes(t) {
    const n = new e.SphereGeometry(1, 32, 32),
      o = new e.Object3D(),
      i = (i, s) => {
        let r = new e.Mesh(n, k.buildDebugMaterial(i));
        (r.renderOrder = t), o.add(r), r.position.fromArray(s);
      };
    return (
      i(16711680, [-50, 0, 0]),
      i(16711680, [50, 0, 0]),
      i(65280, [0, 0, -50]),
      i(65280, [0, 0, 50]),
      i(16755200, [5, 0, 5]),
      o
    );
  }
  createSecondaryDebugMeshes(t) {
    const n = new e.BoxGeometry(3, 3, 3),
      o = new e.Object3D();
    const i = (i) => {
      let s = new e.Mesh(n, k.buildDebugMaterial(12303291));
      (s.renderOrder = t), o.add(s), s.position.fromArray(i);
    };
    let s = 10;
    return i([-10, 0, -10]), i([-10, 0, s]), i([s, 0, -10]), i([s, 0, s]), o;
  }
  static buildDebugMaterial(t) {
    const n = { color: { type: "v3", value: new e.Color(t) } },
      o = new e.ShaderMaterial({
        uniforms: n,
        vertexShader:
          "\n            #include <common>\n            varying float ndcDepth;\n\n            void main() {\n                gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position.xyz, 1.0);\n                ndcDepth = gl_Position.z / gl_Position.w;\n                gl_Position.x = gl_Position.x / gl_Position.w;\n                gl_Position.y = gl_Position.y / gl_Position.w;\n                gl_Position.z = 0.0;\n                gl_Position.w = 1.0;\n    \n            }\n        ",
        fragmentShader:
          "\n            #include <common>\n            uniform vec3 color;\n            varying float ndcDepth;\n            void main() {\n                gl_FragDepth = (ndcDepth + 1.0) / 2.0;\n                gl_FragColor = vec4(color.rgb, 0.0);\n            }\n        ",
        transparent: !1,
        depthTest: !0,
        depthWrite: !0,
        side: e.FrontSide,
      });
    return (o.extensions.fragDepth = !0), o;
  }
  static buildFocusMarkerMaterial(t) {
    const n = {
      color: { type: "v3", value: new e.Color(t) },
      realFocusPosition: { type: "v3", value: new e.Vector3() },
      viewport: { type: "v2", value: new e.Vector2() },
      opacity: { value: 0 },
    };
    return new e.ShaderMaterial({
      uniforms: n,
      vertexShader:
        "\n            #include <common>\n\n            uniform vec2 viewport;\n            uniform vec3 realFocusPosition;\n\n            varying vec4 ndcPosition;\n            varying vec4 ndcCenter;\n            varying vec4 ndcFocusPosition;\n\n            void main() {\n                float radius = 0.01;\n\n                vec4 viewPosition = modelViewMatrix * vec4(position.xyz, 1.0);\n                vec4 viewCenter = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n\n                vec4 viewFocusPosition = modelViewMatrix * vec4(realFocusPosition, 1.0);\n\n                ndcPosition = projectionMatrix * viewPosition;\n                ndcPosition = ndcPosition * vec4(1.0 / ndcPosition.w);\n                ndcCenter = projectionMatrix * viewCenter;\n                ndcCenter = ndcCenter * vec4(1.0 / ndcCenter.w);\n\n                ndcFocusPosition = projectionMatrix * viewFocusPosition;\n                ndcFocusPosition = ndcFocusPosition * vec4(1.0 / ndcFocusPosition.w);\n\n                gl_Position = projectionMatrix * viewPosition;\n\n            }\n        ",
      fragmentShader:
        "\n            #include <common>\n            uniform vec3 color;\n            uniform vec2 viewport;\n            uniform float opacity;\n\n            varying vec4 ndcPosition;\n            varying vec4 ndcCenter;\n            varying vec4 ndcFocusPosition;\n\n            void main() {\n                vec2 screenPosition = vec2(ndcPosition) * viewport;\n                vec2 screenCenter = vec2(ndcCenter) * viewport;\n\n                vec2 screenVec = screenPosition - screenCenter;\n\n                float projectedRadius = length(screenVec);\n\n                float lineWidth = 0.0005 * viewport.y;\n                float aaRange = 0.0025 * viewport.y;\n                float radius = 0.06 * viewport.y;\n                float radDiff = abs(projectedRadius - radius) - lineWidth;\n                float alpha = 1.0 - clamp(radDiff / 5.0, 0.0, 1.0); \n\n                gl_FragColor = vec4(color.rgb, alpha * opacity);\n            }\n        ",
      transparent: !0,
      depthTest: !1,
      depthWrite: !1,
      side: e.FrontSide,
    });
  }
}
const U = new e.Vector3(1, 0, 0),
  _ = new e.Vector3(0, 1, 0),
  O = new e.Vector3(0, 0, 1);
class N {
  constructor(t = new e.Vector3(), n = new e.Vector3()) {
    (this.origin = new e.Vector3()),
      (this.direction = new e.Vector3()),
      this.setParameters(t, n);
  }
  setParameters(e, t) {
    this.origin.copy(e), this.direction.copy(t).normalize();
  }
  boxContainsPoint(e, t, n) {
    return !(
      t.x < e.min.x - n ||
      t.x > e.max.x + n ||
      t.y < e.min.y - n ||
      t.y > e.max.y + n ||
      t.z < e.min.z - n ||
      t.z > e.max.z + n
    );
  }
  intersectBox = (function () {
    const t = new e.Vector3(),
      n = [],
      o = [],
      i = [];
    return function (e, s) {
      if (
        ((o[0] = this.origin.x),
        (o[1] = this.origin.y),
        (o[2] = this.origin.z),
        (i[0] = this.direction.x),
        (i[1] = this.direction.y),
        (i[2] = this.direction.z),
        this.boxContainsPoint(e, this.origin, 1e-4))
      )
        return (
          s &&
            (s.origin.copy(this.origin),
            s.normal.set(0, 0, 0),
            (s.distance = -1)),
          !0
        );
      for (let r = 0; r < 3; r++) {
        if (0 == i[r]) continue;
        const a = 0 == r ? U : 1 == r ? _ : O,
          c = i[r] < 0 ? e.max : e.min;
        let l = -Math.sign(i[r]);
        n[0] = 0 == r ? c.x : 1 == r ? c.y : c.z;
        let h = n[0] - o[r];
        if (h * l < 0) {
          const c = (r + 1) % 3,
            p = (r + 2) % 3;
          if (
            ((n[2] = (i[c] / i[r]) * h + o[c]),
            (n[1] = (i[p] / i[r]) * h + o[p]),
            t.set(n[r], n[p], n[c]),
            this.boxContainsPoint(e, t, 1e-4))
          )
            return (
              s &&
                (s.origin.copy(t),
                s.normal.copy(a).multiplyScalar(l),
                (s.distance = t.sub(this.origin).length())),
              !0
            );
        }
      }
      return !1;
    };
  })();
  intersectSphere = (function () {
    const t = new e.Vector3();
    return function (e, n, o) {
      t.copy(e).sub(this.origin);
      const i = t.dot(this.direction),
        s = i * i,
        r = t.dot(t) - s,
        a = n * n;
      if (r > a) return !1;
      const c = Math.sqrt(a - r),
        l = i - c,
        h = i + c;
      if (h < 0) return !1;
      let p = l < 0 ? h : l;
      return (
        o &&
          (o.origin.copy(this.origin).addScaledVector(this.direction, p),
          o.normal.copy(o.origin).sub(e).normalize(),
          (o.distance = p)),
        !0
      );
    };
  })();
}
class j {
  constructor() {
    (this.origin = new e.Vector3()),
      (this.normal = new e.Vector3()),
      (this.distance = 0);
  }
  set(e, t, n) {
    this.origin.copy(e), this.normal.copy(t), (this.distance = n);
  }
  clone() {
    const e = new j();
    return (
      e.origin.copy(this.origin),
      e.normal.copy(this.normal),
      (e.distance = this.distance),
      e
    );
  }
}
class H {
  constructor(e, t) {
    this.ray = new N(e, t);
  }
  setFromCameraAndScreenPosition = (function () {
    const t = new e.Vector2();
    return function (e, n, o) {
      if (
        ((t.x = (n.x / o.x) * 2 - 1),
        (t.y = ((o.y - n.y) / o.y) * 2 - 1),
        e.isPerspectiveCamera)
      )
        this.ray.origin.setFromMatrixPosition(e.matrixWorld),
          this.ray.direction
            .set(t.x, t.y, 0.5)
            .unproject(e)
            .sub(this.ray.origin)
            .normalize(),
          (this.camera = e);
      else {
        if (!e.isOrthographicCamera)
          throw new Error(
            "Raycaster::setFromCameraAndScreenPosition() -> Unsupported camera type"
          );
        this.ray.origin
          .set(n.x, n.y, (e.near + e.far) / (e.near - e.far))
          .unproject(e),
          this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld),
          (this.camera = e);
      }
    };
  })();
  intersectSplatMesh = (function () {
    const t = new e.Matrix4(),
      n = new e.Matrix4(),
      o = new N();
    return function (e, i = []) {
      n.copy(e.matrixWorld),
        t.copy(n).invert(),
        o.origin.copy(this.ray.origin).applyMatrix4(t),
        o.direction.copy(this.ray.direction).transformDirection(t);
      const s = e.getSplatTree();
      return (
        s.rootNode && this.castRayAtSplatTreeNode(o, s, s.rootNode, i),
        i.sort((e, t) => (e.distance > t.distance ? 1 : -1)),
        i.forEach((e) => {
          e.origin.applyMatrix4(n), e.normal.transformDirection(n);
        }),
        i
      );
    };
  })();
  castRayAtSplatTreeNode = (function () {
    const t = new e.Vector3(),
      n = new e.Vector3(),
      o = new e.Quaternion(),
      i = new j(),
      s = 1e-7;
    return function (e, r, a, c = []) {
      if (e.intersectBox(a.boundingBox)) {
        if (a.data.indexes && a.data.indexes.length > 0)
          for (let l = 0; l < a.data.indexes.length; l++) {
            const h = a.data.indexes[l];
            if (
              (r.splatBuffer.getPosition(h, t),
              r.splatBuffer.getRotation(h, o),
              r.splatBuffer.getScale(h, n),
              n.x <= s || n.y <= s || n.z <= s)
            )
              continue;
            const p = (n.x + n.y + n.z) / 3;
            e.intersectSphere(t, p, i) && c.push(i.clone());
          }
        if (a.children && a.children.length > 0)
          for (let t of a.children) this.castRayAtSplatTreeNode(e, r, t, c);
        return c;
      }
    };
  })();
}
let W = 0;
class Y {
  constructor(t, n, o, i) {
    (this.min = new e.Vector3().copy(t)),
      (this.max = new e.Vector3().copy(n)),
      (this.boundingBox = new e.Box3(this.min, this.max)),
      (this.center = new e.Vector3()
        .copy(this.max)
        .sub(this.min)
        .multiplyScalar(0.5)
        .add(this.min)),
      (this.depth = o),
      (this.children = []),
      (this.data = null),
      (this.id = i || W++);
  }
}
class G {
  constructor(t, n) {
    (this.maxDepth = t),
      (this.maxPositionsPerNode = n),
      (this.splatBuffer = null),
      (this.sceneDimensions = new e.Vector3()),
      (this.sceneMin = new e.Vector3()),
      (this.sceneMax = new e.Vector3()),
      (this.rootNode = null),
      (this.addedIndexes = {}),
      (this.nodesWithIndexes = []);
  }
  processSplatBuffer(t, n = () => !0) {
    (this.splatBuffer = t),
      (this.addedIndexes = {}),
      (this.nodesWithIndexes = []);
    const o = t.getSplatCount(),
      i = new e.Vector3();
    for (let e = 0; e < o; e++)
      n(e) &&
        (t.getPosition(e, i),
        (0 === e || i.x < this.sceneMin.x) && (this.sceneMin.x = i.x),
        (0 === e || i.x > this.sceneMax.x) && (this.sceneMax.x = i.x),
        (0 === e || i.y < this.sceneMin.y) && (this.sceneMin.y = i.y),
        (0 === e || i.y > this.sceneMax.y) && (this.sceneMax.y = i.y),
        (0 === e || i.z < this.sceneMin.z) && (this.sceneMin.z = i.z),
        (0 === e || i.z > this.sceneMax.z) && (this.sceneMax.z = i.z));
    this.sceneDimensions.copy(this.sceneMin).sub(this.sceneMin);
    const s = [];
    for (let e = 0; e < o; e++) n(e) && s.push(e);
    (this.rootNode = new Y(this.sceneMin, this.sceneMax, 0)),
      (this.rootNode.data = { indexes: s }),
      this.processNode(this.rootNode, t);
  }
  processNode(t, n) {
    const o = t.data.indexes.length;
    if (o < this.maxPositionsPerNode || t.depth > this.maxDepth) {
      const e = [];
      for (let n = 0; n < t.data.indexes.length; n++)
        this.addedIndexes[t.data.indexes[n]] ||
          (e.push(t.data.indexes[n]),
          (this.addedIndexes[t.data.indexes[n]] = !0));
      return (t.data.indexes = e), void this.nodesWithIndexes.push(t);
    }
    const i = new e.Vector3().copy(t.max).sub(t.min),
      s = new e.Vector3().copy(i).multiplyScalar(0.5),
      r = new e.Vector3().copy(t.min).add(s),
      a = [
        new e.Box3(
          new e.Vector3(r.x - s.x, r.y, r.z - s.z),
          new e.Vector3(r.x, r.y + s.y, r.z)
        ),
        new e.Box3(
          new e.Vector3(r.x, r.y, r.z - s.z),
          new e.Vector3(r.x + s.x, r.y + s.y, r.z)
        ),
        new e.Box3(
          new e.Vector3(r.x, r.y, r.z),
          new e.Vector3(r.x + s.x, r.y + s.y, r.z + s.z)
        ),
        new e.Box3(
          new e.Vector3(r.x - s.x, r.y, r.z),
          new e.Vector3(r.x, r.y + s.y, r.z + s.z)
        ),
        new e.Box3(
          new e.Vector3(r.x - s.x, r.y - s.y, r.z - s.z),
          new e.Vector3(r.x, r.y, r.z)
        ),
        new e.Box3(
          new e.Vector3(r.x, r.y - s.y, r.z - s.z),
          new e.Vector3(r.x + s.x, r.y, r.z)
        ),
        new e.Box3(
          new e.Vector3(r.x, r.y - s.y, r.z),
          new e.Vector3(r.x + s.x, r.y, r.z + s.z)
        ),
        new e.Box3(
          new e.Vector3(r.x - s.x, r.y - s.y, r.z),
          new e.Vector3(r.x, r.y, r.z + s.z)
        ),
      ],
      c = [],
      l = [];
    for (let e = 0; e < a.length; e++) (c[e] = 0), (l[e] = []);
    const h = new e.Vector3();
    for (let e = 0; e < o; e++) {
      const o = t.data.indexes[e];
      n.getPosition(o, h);
      for (let e = 0; e < a.length; e++)
        a[e].containsPoint(h) && (c[e]++, l[e].push(o));
    }
    for (let e = 0; e < a.length; e++) {
      const n = new Y(a[e].min, a[e].max, t.depth + 1);
      (n.data = { indexes: l[e] }), t.children.push(n);
    }
    t.data = {};
    for (let e of t.children) this.processNode(e, n);
  }
  countLeaves() {
    let e = 0;
    return (
      this.visitLeaves(() => {
        e++;
      }),
      e
    );
  }
  visitLeaves(e) {
    const t = (e, n) => {
      0 === e.children.length && n(e);
      for (let o of e.children) t(o, n);
    };
    return t(this.rootNode, e);
  }
}
class Q extends e.Mesh {
  static buildMesh(e, t = 1, n = !1, o = 1) {
    const i = Q.buildGeomtery(e),
      s = Q.buildMaterial();
    return new Q(e, i, s, t, n, o);
  }
  constructor(e, t, n, o = 1, i = !1, s = 1) {
    super(t, n),
      (this.splatBuffer = e),
      (this.geometry = t),
      (this.material = n),
      (this.splatTree = null),
      (this.splatDataTextures = null),
      (this.splatAlphaRemovalThreshold = o),
      (this.halfPrecisionCovariancesOnGPU = i),
      (this.devicePixelRatio = s),
      this.buildSplatTree(),
      this.resetLocalSplatDataAndTexturesFromSplatBuffer();
  }
  static buildMaterial() {
    const t = {
      covariancesTexture: { type: "t", value: null },
      centersColorsTexture: { type: "t", value: null },
      focal: { type: "v2", value: new e.Vector2() },
      viewport: { type: "v2", value: new e.Vector2() },
      basisViewport: { type: "v2", value: new e.Vector2() },
      debugColor: { type: "v3", value: new e.Color() },
      covariancesTextureSize: { type: "v2", value: new e.Vector2(1024, 1024) },
      centersColorsTextureSize: {
        type: "v2",
        value: new e.Vector2(1024, 1024),
      },
    };
    return new e.ShaderMaterial({
      uniforms: t,
      vertexShader:
        "\n            precision highp float;\n            #include <common>\n\n            attribute uint splatIndex;\n\n            uniform highp sampler2D covariancesTexture;\n            uniform highp usampler2D centersColorsTexture;\n            uniform vec2 focal;\n            uniform vec2 viewport;\n            uniform vec2 basisViewport;\n            uniform vec2 covariancesTextureSize;\n            uniform vec2 centersColorsTextureSize;\n\n            varying vec4 vColor;\n            varying vec2 vUv;\n\n            varying vec2 vPosition;\n\n            const vec4 encodeNorm4 = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n            const uvec4 mask4 = uvec4(uint(0x000000FF), uint(0x0000FF00), uint(0x00FF0000), uint(0xFF000000));\n            const uvec4 shift4 = uvec4(0, 8, 16, 24);\n            vec4 uintToRGBAVec (uint u) {\n               uvec4 urgba = mask4 & u;\n               urgba = urgba >> shift4;\n               vec4 rgba = vec4(urgba) * encodeNorm4;\n               return rgba;\n            }\n\n            vec2 getDataUV(in int stride, in int offset, in vec2 dimensions) {\n                vec2 samplerUV = vec2(0.0, 0.0);\n                float d = float(splatIndex * uint(stride) + uint(offset)) / dimensions.x;\n                samplerUV.y = float(floor(d)) / dimensions.y;\n                samplerUV.x = fract(d);\n                return samplerUV;\n            }\n\n            void main () {\n                uvec4 sampledCenterColor = texture(centersColorsTexture, getDataUV(1, 0, centersColorsTextureSize));\n                vec3 splatCenter = uintBitsToFloat(uvec3(sampledCenterColor.gba));\n                vColor = uintToRGBAVec(sampledCenterColor.r);\n\n                vPosition = position.xy * 2.0;\n\n                vec4 viewCenter = modelViewMatrix * vec4(splatCenter, 1.0);\n                vec4 clipCenter = projectionMatrix * viewCenter;\n\n                vec2 sampledCovarianceA = texture(covariancesTexture, getDataUV(3, 0, covariancesTextureSize)).rg;\n                vec2 sampledCovarianceB = texture(covariancesTexture, getDataUV(3, 1, covariancesTextureSize)).rg;\n                vec2 sampledCovarianceC = texture(covariancesTexture, getDataUV(3, 2, covariancesTextureSize)).rg;\n\n                vec3 cov3D_M11_M12_M13 = vec3(sampledCovarianceA.rg, sampledCovarianceB.r);\n                vec3 cov3D_M22_M23_M33 = vec3(sampledCovarianceB.g, sampledCovarianceC.rg);\n\n                // Compute the 2D covariance matrix from the upper-right portion of the 3D covariance matrix\n                mat3 Vrk = mat3(\n                    cov3D_M11_M12_M13.x, cov3D_M11_M12_M13.y, cov3D_M11_M12_M13.z,\n                    cov3D_M11_M12_M13.y, cov3D_M22_M23_M33.x, cov3D_M22_M23_M33.y,\n                    cov3D_M11_M12_M13.z, cov3D_M22_M23_M33.y, cov3D_M22_M23_M33.z\n                );\n                float s = 1.0 / (viewCenter.z * viewCenter.z);\n                mat3 J = mat3(\n                    focal.x / viewCenter.z, 0., -(focal.x * viewCenter.x) * s,\n                    0., focal.y / viewCenter.z, -(focal.y * viewCenter.y) * s,\n                    0., 0., 0.\n                );\n                mat3 W = transpose(mat3(modelViewMatrix));\n                mat3 T = W * J;\n                mat3 cov2Dm = transpose(T) * Vrk * T;\n                cov2Dm[0][0] += 0.3;\n                cov2Dm[1][1] += 0.3;\n\n                // We are interested in the upper-left 2x2 portion of the projected 3D covariance matrix because\n                // we only care about the X and Y values. We want the X-diagonal, cov2Dm[0][0],\n                // the Y-diagonal, cov2Dm[1][1], and the correlation between the two cov2Dm[0][1]. We don't\n                // need cov2Dm[1][0] because it is a symetric matrix.\n                vec3 cov2Dv = vec3(cov2Dm[0][0], cov2Dm[0][1], cov2Dm[1][1]);\n\n                vec3 ndcCenter = clipCenter.xyz / clipCenter.w;\n\n                // We now need to solve for the eigen-values and eigen vectors of the 2D covariance matrix\n                // so that we can determine the 2D basis for the splat. This is done using the method described\n                // here: https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html\n                //\n                // This is a different approach than in the original work at INRIA. In that work they compute the\n                // max extents of the 2D covariance matrix in screen space to form an axis aligned bounding rectangle\n                // which forms the geometry that is actually rasterized. They then use the inverse 2D covariance\n                // matrix (called 'conic') to determine fragment opacity.\n                float a = cov2Dv.x;\n                float d = cov2Dv.z;\n                float b = cov2Dv.y;\n                float D = a * d - b * b;\n                float trace = a + d;\n                float traceOver2 = 0.5 * trace;\n                float term2 = sqrt(trace * trace / 4.0 - D);\n                float eigenValue1 = traceOver2 + term2;\n                float eigenValue2 = max(traceOver2 - term2, 0.00); // prevent negative eigen value\n\n                const float maxSplatSize = 1024.0;\n                vec2 eigenVector1 = normalize(vec2(b, eigenValue1 - a));\n                // since the eigen vectors are orthogonal, we derive the second one from the first\n                vec2 eigenVector2 = vec2(eigenVector1.y, -eigenVector1.x);\n                vec2 basisVector1 = eigenVector1 * min(sqrt(2.0 * eigenValue1), maxSplatSize);\n                vec2 basisVector2 = eigenVector2 * min(sqrt(2.0 * eigenValue2), maxSplatSize);\n\n                vec2 ndcOffset = vec2(vPosition.x * basisVector1 + vPosition.y * basisVector2) * basisViewport;\n\n                gl_Position = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);\n            }",
      fragmentShader:
        "\n            precision highp float;\n            #include <common>\n\n            uniform vec3 debugColor;\n\n            varying vec4 vColor;\n            varying vec2 vUv;\n\n            varying vec2 vPosition;\n\n            void main () {\n                // compute the negative squared distance from the center of the splat to the\n                // current fragment in the splat's local space.\n                float A = -dot(vPosition, vPosition);\n                if (A < -4.0) discard;\n                vec3 color = vColor.rgb;\n                A = exp(A) * vColor.a;\n                gl_FragColor = vec4(color.rgb, A);\n            }",
      transparent: !0,
      alphaTest: 1,
      blending: e.NormalBlending,
      depthTest: !0,
      depthWrite: !1,
      side: e.DoubleSide,
    });
  }
  static buildGeomtery(t) {
    const n = t.getSplatCount(),
      o = new e.BufferGeometry();
    o.setIndex([0, 1, 2, 0, 2, 3]);
    const i = new Float32Array(12),
      s = new e.BufferAttribute(i, 3);
    o.setAttribute("position", s),
      s.setXYZ(0, -1, -1, 0),
      s.setXYZ(1, -1, 1, 0),
      s.setXYZ(2, 1, 1, 0),
      s.setXYZ(3, 1, -1, 0),
      (s.needsUpdate = !0);
    const r = new e.InstancedBufferGeometry().copy(o),
      a = new Uint32Array(n),
      c = new e.InstancedBufferAttribute(a, 1, !1);
    return (
      c.setUsage(e.DynamicDrawUsage),
      r.setAttribute("splatIndex", c),
      (r.instanceCount = n),
      r
    );
  }
  buildSplatTree() {
    (this.splatTree = new G(10, 500)), console.time("SplatTree build");
    const t = new e.Vector4();
    this.splatTree.processSplatBuffer(
      this.splatBuffer,
      (e) => (
        this.splatBuffer.getColor(e, t), t.w > this.splatAlphaRemovalThreshold
      )
    ),
      console.timeEnd("SplatTree build");
    let n = 0,
      o = 0,
      i = 0,
      s = 0;
    this.splatTree.visitLeaves((e) => {
      const t = e.data.indexes.length;
      t > 0 && ((o += t), (i = Math.max(i, t)), s++, n++);
    }),
      console.log(`SplatTree leaves: ${this.splatTree.countLeaves()}`),
      console.log(`SplatTree leaves with splats:${n}`),
      (o /= s),
      console.log(`Avg splat count per node: ${o}`);
  }
  getSplatTree() {
    return this.splatTree;
  }
  resetLocalSplatDataAndTexturesFromSplatBuffer() {
    this.updateLocalSplatDataFromSplatBuffer(),
      this.allocateAndStoreLocalSplatDataInTextures();
  }
  updateLocalSplatDataFromSplatBuffer() {
    const e = this.splatBuffer.getSplatCount();
    (this.covariances = new Float32Array(
      this.splatBuffer.getPrecomputedCovarianceBufferData()
    )),
      (this.colors = new Uint8Array(4 * e)),
      (this.centers = new Float32Array(3 * e)),
      this.splatBuffer.fillPositionArray(this.centers),
      this.splatBuffer.fillColorArray(this.colors);
  }
  allocateAndStoreLocalSplatDataInTextures() {
    const t = this.splatBuffer.getSplatCount(),
      n = new e.Vector2(4096, 1024);
    for (; n.x * n.y * 2 < 6 * t; ) n.y *= 2;
    const o = new e.Vector2(4096, 1024);
    for (; o.x * o.y * 4 < 4 * t; ) o.y *= 2;
    let i, s;
    if (this.halfPrecisionCovariancesOnGPU) {
      s = new Uint16Array(n.x * n.y * 2);
      for (let t = 0; t < this.covariances.length; t++)
        s[t] = e.DataUtils.toHalfFloat(this.covariances[t]);
      i = new e.DataTexture(s, n.x, n.y, e.RGFormat, e.HalfFloatType);
    } else
      (s = new Float32Array(n.x * n.y * 2)),
        s.set(this.covariances),
        (i = new e.DataTexture(s, n.x, n.y, e.RGFormat, e.FloatType));
    (i.needsUpdate = !0),
      (this.material.uniforms.covariancesTexture.value = i),
      this.material.uniforms.covariancesTextureSize.value.copy(n);
    const r = new Uint32Array(o.x * o.y * 4);
    for (let e = 0; e < t; e++) {
      const t = 4 * e,
        n = 3 * e,
        o = 4 * e;
      (r[o] =
        ((a = this.colors[t]),
        (c = this.colors[t + 1]),
        (l = this.colors[t + 2]),
        (h = this.colors[t + 3]),
        a + (c << 8) + (l << 16) + (h << 24))),
        (r[o + 1] = w(this.centers[n])),
        (r[o + 2] = w(this.centers[n + 1])),
        (r[o + 3] = w(this.centers[n + 2]));
    }
    var a, c, l, h;
    const p = new e.DataTexture(
      r,
      o.x,
      o.y,
      e.RGBAIntegerFormat,
      e.UnsignedIntType
    );
    (p.internalFormat = "RGBA32UI"),
      (p.needsUpdate = !0),
      (this.material.uniforms.centersColorsTexture.value = p),
      this.material.uniforms.centersColorsTextureSize.value.copy(o),
      (this.material.uniformsNeedUpdate = !0),
      (this.splatDataTextures = {
        covariances: { data: s, texture: i, size: n },
        centerColors: { data: r, texture: p, size: o },
      });
  }
  updateSplatDataToDataTextures() {
    this.updateLocalCovarianceDataToDataTexture(),
      this.updateLocalCenterColorDataToDataTexture();
  }
  updateLocalCovarianceDataToDataTexture() {
    this.splatDataTextures.covariances.data.set(this.covariances),
      (this.splatDataTextures.covariances.texture.needsUpdate = !0);
  }
  updateLocalCenterColorDataToDataTexture() {
    this.splatDataTextures.centerColors.data.set(this.centerColors),
      (this.splatDataTextures.centerColors.texture.needsUpdate = !0);
  }
  updateIndexes(e, t) {
    const n = this.geometry;
    n.attributes.splatIndex.set(e),
      (n.attributes.splatIndex.needsUpdate = !0),
      (n.instanceCount = t);
  }
  updateUniforms = (function () {
    const t = new e.Vector2();
    return function (e, n, o) {
      this.splatBuffer.getSplatCount() > 0 &&
        (t.set(e.x * this.devicePixelRatio, e.y * this.devicePixelRatio),
        this.material.uniforms.viewport.value.copy(t),
        this.material.uniforms.basisViewport.value.set(2 / t.x, 2 / t.y),
        this.material.uniforms.focal.value.set(n, o),
        (this.material.uniformsNeedUpdate = !0));
    };
  })();
  getSplatDataTextures() {
    return this.splatDataTextures;
  }
  getSplatCount() {
    return this.splatBuffer.getSplatCount();
  }
  getCenters() {
    return this.centers;
  }
  getColors() {
    return this.colors;
  }
  getCovariances() {
    return this.covariances;
  }
}
class K {
  static DepthMapRange = 65536;
  static MemoryPageSize = 65536;
  static BytesPerFloat = 4;
  static BytesPerInt = 4;
}
function X(e) {
  let t, n, o, i, s, r, a, c, l, h, p;
  e.onmessage = (u) => {
    if (u.data.positions) {
      l = u.data.positions;
      const t = new Float32Array(l),
        o = new Int32Array(3 * n);
      for (let e = 0; e < 3 * n; e++) o[e] = Math.round(1e3 * t[e]);
      new Int32Array(c, i, 3 * n).set(o),
        e.postMessage({ sortSetupComplete: !0 });
    } else if (u.data.sort) {
      const l = u.data.sort.splatRenderCount || 0;
      !(function (l, u, d, m) {
        const f = performance.now();
        h || (h = new Uint32Array(p.DepthMapRange));
        const y = new Int32Array(c, s, 16);
        for (let e = 0; e < 16; e++) y[e] = Math.round(1e3 * d[e]);
        new Uint32Array(c, a + 4 * n, p.DepthMapRange).set(h),
          t.exports.sortIndexes(
            o,
            i,
            a,
            s,
            r,
            m[0],
            m[1],
            m[2],
            p.DepthMapRange,
            l,
            u,
            n
          );
        const g = performance.now();
        e.postMessage({
          sortDone: !0,
          splatSortCount: l,
          splatRenderCount: u,
          sortTime: g - f,
        });
      })(
        u.data.sort.splatSortCount || 0,
        l,
        u.data.sort.view,
        u.data.sort.cameraPosition,
        u.data.sort.inIndexBuffer
      );
    } else if (u.data.init) {
      (p = u.data.init.Constants), (n = u.data.init.splatCount);
      const l = p.BytesPerInt,
        h = 3 * p.BytesPerFloat,
        d = new Uint8Array(u.data.init.sorterWasmBytes),
        m =
          n * (l + h) +
          (n * p.BytesPerInt * 2 + p.DepthMapRange * p.BytesPerInt * 2) +
          32 * p.MemoryPageSize,
        f = Math.floor(m / p.MemoryPageSize) + 1,
        y = {
          module: {},
          env: {
            memory: new WebAssembly.Memory({
              initial: 2 * f,
              maximum: 3 * f,
              shared: !0,
            }),
          },
        };
      WebAssembly.compile(d)
        .then((e) => WebAssembly.instantiate(e, y))
        .then((u) => {
          (t = u),
            (o = 0),
            (i = n * l),
            (s = i + n * h),
            (a = s + 16 * p.BytesPerFloat),
            (r = a + n * p.BytesPerInt + p.DepthMapRange * p.BytesPerInt * 2),
            (c = y.env.memory.buffer),
            e.postMessage({
              sortSetupPhase1Complete: !0,
              inIndexBuffer: c,
              inIndexOffset: 0,
              outIndexBuffer: c,
              outIndexOffset: r,
            });
        });
    }
  };
}
class $ {
  constructor(t = {}) {
    t.cameraUp || (t.cameraUp = [0, 1, 0]),
      t.initialCameraPosition || (t.initialCameraPosition = [0, 10, 15]),
      t.initialCameraLookAt || (t.initialCameraLookAt = [0, 0, 0]),
      void 0 === t.selfDrivenMode && (t.selfDrivenMode = !0),
      void 0 === t.useBuiltInControls && (t.useBuiltInControls = !0),
      (this.rootElement = t.rootElement),
      (this.usingExternalCamera = !!t.camera),
      (this.usingExternalRenderer = !!t.renderer),
      (this.cameraUp = new e.Vector3().fromArray(t.cameraUp)),
      (this.initialCameraPosition = new e.Vector3().fromArray(
        t.initialCameraPosition
      )),
      (this.initialCameraLookAt = new e.Vector3().fromArray(
        t.initialCameraLookAt
      )),
      (this.scene = t.scene),
      (this.simpleScene = t.simpleScene),
      (this.renderer = t.renderer),
      (this.camera = t.camera),
      (this.useBuiltInControls = t.useBuiltInControls),
      (this.controls = null),
      (this.ignoreDevicePixelRatio = t.ignoreDevicePixelRatio || !1),
      (this.devicePixelRatio = this.ignoreDevicePixelRatio
        ? 1
        : window.devicePixelRatio),
      (this.selfDrivenMode = t.selfDrivenMode),
      (this.selfDrivenUpdateFunc = this.selfDrivenUpdate.bind(this)),
      (this.showMeshCursor = !1),
      (this.showControlPlane = !1),
      (this.showInfo = !1),
      (this.sceneHelper = null),
      (this.sortWorker = null),
      (this.splatRenderCount = 0),
      (this.splatSortCount = 0),
      (this.inIndexArray = null),
      (this.splatMesh = null),
      (this.sortRunning = !1),
      (this.selfDrivenModeRunning = !1),
      (this.splatRenderingInitialized = !1),
      (this.raycaster = new H()),
      (this.infoPanel = null),
      (this.infoPanelCells = {}),
      (this.currentFPS = 0),
      (this.lastSortTime = 0),
      (this.previousCameraTarget = new e.Vector3()),
      (this.nextCameraTarget = new e.Vector3()),
      (this.mousePosition = new e.Vector2()),
      (this.mouseDownPosition = new e.Vector2()),
      (this.mouseDownTime = null),
      (this.loadingSpinner = new L()),
      this.loadingSpinner.hide(),
      (this.initialized = !1),
      this.init();
  }
  init() {
    if (this.initialized) return;
    this.rootElement ||
      this.usingExternalRenderer ||
      ((this.rootElement = document.createElement("div")),
      (this.rootElement.style.width = "100%"),
      (this.rootElement.style.height = "100%"),
      document.body.appendChild(this.rootElement));
    const t = new e.Vector2();
    if (
      (this.getRenderDimensions(t),
      this.usingExternalCamera ||
        ((this.camera = new e.PerspectiveCamera(50, t.x / t.y, 0.1, 500)),
        this.camera.position.copy(this.initialCameraPosition),
        this.camera.lookAt(this.initialCameraLookAt),
        this.camera.up.copy(this.cameraUp).normalize()),
      (this.scene = this.scene || new e.Scene()),
      (this.simpleScene = this.simpleScene || new e.Scene()),
      (this.sceneHelper = new k(this.scene, this.simpleScene)),
      this.sceneHelper.setupMeshCursor(),
      this.sceneHelper.setupFocusMarker(),
      this.sceneHelper.setupControlPlane(),
      this.usingExternalRenderer ||
        ((this.renderer = new e.WebGLRenderer({
          antialias: !1,
          precision: "highp",
        })),
        this.renderer.setPixelRatio(this.devicePixelRatio),
        (this.renderer.autoClear = !0),
        this.renderer.setClearColor(0, 0, 0, 0),
        this.renderer.setSize(t.x, t.y)),
      this.setupRenderTargetCopyObjects(),
      this.useBuiltInControls &&
        ((this.controls = new I(this.camera, this.renderer.domElement)),
        this.controls.listenToKeyEvents(window),
        (this.controls.rotateSpeed = 0.5),
        (this.controls.maxPolarAngle = 0.75 * Math.PI),
        (this.controls.minPolarAngle = 0.1),
        (this.controls.enableDamping = !0),
        (this.controls.dampingFactor = 0.05),
        this.controls.target.copy(this.initialCameraLookAt),
        this.rootElement.addEventListener(
          "pointermove",
          this.onMouseMove.bind(this),
          !1
        ),
        this.rootElement.addEventListener(
          "pointerdown",
          this.onMouseDown.bind(this),
          !1
        ),
        this.rootElement.addEventListener(
          "pointerup",
          this.onMouseUp.bind(this),
          !1
        ),
        window.addEventListener("keydown", this.onKeyDown.bind(this), !1)),
      !this.usingExternalRenderer)
    ) {
      new ResizeObserver(() => {
        this.getRenderDimensions(t), this.renderer.setSize(t.x, t.y);
      }).observe(this.rootElement),
        this.rootElement.appendChild(this.renderer.domElement);
    }
    this.setupSimpleObjectDepthOverrideMaterial(),
      this.setupInfoPanel(),
      (this.initialized = !0);
  }
  onKeyDown = (function () {
    const t = new e.Vector3(),
      n = new e.Matrix4(),
      o = new e.Matrix4();
    return function (e) {
      switch (
        (t.set(0, 0, -1),
        t.transformDirection(this.camera.matrixWorld),
        n.makeRotationAxis(t, Math.PI / 128),
        o.makeRotationAxis(t, -Math.PI / 128),
        e.code)
      ) {
        case "ArrowLeft":
          this.camera.up.transformDirection(n);
          break;
        case "ArrowRight":
          this.camera.up.transformDirection(o);
          break;
        case "KeyC":
          this.showMeshCursor = !this.showMeshCursor;
          break;
        case "KeyP":
          this.showControlPlane = !this.showControlPlane;
          break;
        case "KeyI":
          (this.showInfo = !this.showInfo),
            this.showInfo
              ? (this.infoPanel.style.display = "block")
              : (this.infoPanel.style.display = "none");
      }
    };
  })();
  onMouseMove(e) {
    this.mousePosition.set(e.offsetX, e.offsetY);
  }
  onMouseDown() {
    this.mouseDownPosition.copy(this.mousePosition), (this.mouseDownTime = b());
  }
  onMouseUp = (function () {
    const t = new e.Vector2(),
      n = new e.Vector2(),
      o = [];
    return function (e) {
      n.copy(this.mousePosition).sub(this.mouseDownPosition);
      const i = b() - this.mouseDownTime < 0.5 && n.length() < 2;
      !this.transitioningCameraTarget &&
        i &&
        (this.getRenderDimensions(t),
        (o.length = 0),
        this.raycaster.setFromCameraAndScreenPosition(
          this.camera,
          this.mousePosition,
          t
        ),
        this.mousePosition.set(e.offsetX, e.offsetY),
        this.raycaster.intersectSplatMesh(this.splatMesh, o),
        o.length > 0 &&
          (this.previousCameraTarget.copy(this.controls.target),
          this.nextCameraTarget.copy(o[0].origin),
          (this.transitioningCameraTarget = !0),
          (this.transitioningCameraTargetStartTime = b())));
    };
  })();
  getRenderDimensions(e) {
    this.rootElement
      ? ((e.x = this.rootElement.offsetWidth),
        (e.y = this.rootElement.offsetHeight))
      : this.renderer.getSize(e);
  }
  setupInfoPanel() {
    (this.infoPanel = document.createElement("div")),
      (this.infoPanel.style.position = "absolute"),
      (this.infoPanel.style.padding = "10px"),
      (this.infoPanel.style.backgroundColor = "#cccccc"),
      (this.infoPanel.style.border = "#aaaaaa 1px solid"),
      (this.infoPanel.style.zIndex = 100),
      (this.infoPanel.style.width = "375px"),
      (this.infoPanel.style.fontFamily = "arial"),
      (this.infoPanel.style.fontSize = "10pt"),
      (this.infoPanel.style.textAlign = "left");
    const e = [
        ["Camera position", "cameraPosition"],
        ["Camera look-at", "cameraLookAt"],
        ["Camera up", "cameraUp"],
        ["Cursor position", "cursorPosition"],
        ["FPS", "fps"],
        ["Render window", "renderWindow"],
        ["Rendering:", "renderSplatCount"],
        ["Sort time", "sortTime"],
      ],
      t = document.createElement("div");
    t.style.display = "table";
    for (let n of e) {
      const e = document.createElement("div");
      e.style.display = "table-row";
      const o = document.createElement("div");
      (o.style.display = "table-cell"),
        (o.style.width = "110px"),
        (o.innerHTML = `${n[0]}: `);
      const i = document.createElement("div");
      (i.style.display = "table-cell"),
        (i.style.width = "10px"),
        (i.innerHTML = " ");
      const s = document.createElement("div");
      (s.style.display = "table-cell"),
        (s.innerHTML = ""),
        (this.infoPanelCells[n[1]] = s),
        e.appendChild(o),
        e.appendChild(i),
        e.appendChild(s),
        t.appendChild(e);
    }
    this.infoPanel.appendChild(t),
      (this.infoPanel.style.display = "none"),
      this.renderer.domElement.parentElement.prepend(this.infoPanel);
  }
  updateSplatRenderTargetForRenderDimensions(t, n) {
    (this.splatRenderTarget = new e.WebGLRenderTarget(t, n, {
      format: e.RGBAFormat,
      stencilBuffer: !1,
      depthBuffer: !0,
    })),
      (this.splatRenderTarget.depthTexture = new e.DepthTexture(t, n)),
      (this.splatRenderTarget.depthTexture.format = e.DepthFormat),
      (this.splatRenderTarget.depthTexture.type = e.UnsignedIntType);
  }
  setupSimpleObjectDepthOverrideMaterial() {
    this.simpleObjectDepthOverrideMaterial = new e.ShaderMaterial({
      vertexShader:
        "\n                #include <common>\n                void main() {\n                    gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position.xyz, 1.0);   \n                }\n            ",
      fragmentShader:
        "\n                #include <common>\n                void main() {\n                    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n              }\n            ",
      depthWrite: !0,
      depthTest: !0,
      transparent: !1,
    });
  }
  setupRenderTargetCopyObjects() {
    (this.renderTargetCopyMaterial = new e.ShaderMaterial({
      vertexShader:
        "\n                varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = vec4( position.xy, 0.0, 1.0 );    \n                }\n            ",
      fragmentShader:
        "\n                #include <common>\n                #include <packing>\n                varying vec2 vUv;\n                uniform sampler2D sourceColorTexture;\n                uniform sampler2D sourceDepthTexture;\n                void main() {\n                    vec4 color = texture2D(sourceColorTexture, vUv);\n                    float fragDepth = texture2D(sourceDepthTexture, vUv).x;\n                    gl_FragDepth = fragDepth;\n                    gl_FragColor = vec4(color.rgb, color.a * 2.0);\n              }\n            ",
      uniforms: {
        sourceColorTexture: { type: "t", value: null },
        sourceDepthTexture: { type: "t", value: null },
      },
      depthWrite: !1,
      depthTest: !1,
      transparent: !0,
      blending: e.CustomBlending,
      blendSrc: e.SrcAlphaFactor,
      blendSrcAlpha: e.SrcAlphaFactor,
      blendDst: e.OneMinusSrcAlphaFactor,
      blendDstAlpha: e.OneMinusSrcAlphaFactor,
    })),
      (this.renderTargetCopyMaterial.extensions.fragDepth = !0),
      (this.renderTargetCopyQuad = new e.Mesh(
        new e.PlaneGeometry(2, 2),
        this.renderTargetCopyMaterial
      )),
      (this.renderTargetCopyCamera = new e.OrthographicCamera(
        -1,
        1,
        1,
        -1,
        0,
        1
      ));
  }
  updateSplatMeshUniforms = (function () {
    const t = new e.Vector2();
    return function () {
      this.splatMesh.getSplatCount() > 0 &&
        (this.getRenderDimensions(t),
        (this.cameraFocalLengthX =
          this.camera.projectionMatrix.elements[0] *
          this.devicePixelRatio *
          t.x *
          0.45),
        (this.cameraFocalLengthY =
          this.camera.projectionMatrix.elements[5] *
          this.devicePixelRatio *
          t.y *
          0.45),
        this.splatMesh.updateUniforms(
          t,
          this.cameraFocalLengthX,
          this.cameraFocalLengthY
        ));
    };
  })();
  loadFile(t, n = {}) {
    n.position && (n.position = new e.Vector3().fromArray(n.position)),
      n.orientation &&
        (n.orientation = new e.Quaternion().fromArray(n.orientation)),
      (n.splatAlphaRemovalThreshold = n.splatAlphaRemovalThreshold || 1),
      (n.halfPrecisionCovariancesOnGPU = !!n.halfPrecisionCovariancesOnGPU),
      this.loadingSpinner.show();
    const o = (e, t) => {
      100 == e
        ? this.loadingSpinner.setMessage("Download complete!")
        : t
        ? this.loadingSpinner.setMessage(`Downloading: ${t}`)
        : this.loadingSpinner.setMessage("Downloading...");
    };
    return new Promise((e, i) => {
      let s;
      t.endsWith(".splat")
        ? (s = new D().loadFromURL(t, o))
        : t.endsWith(".ply")
        ? (s = new S().loadFromURL(t, o))
        : i(new Error(`Viewer::loadFile -> File format not supported: ${t}`)),
        s
          .then((t) => {
            this.loadingSpinner.hide(),
              this.loadSplatBuffer(t, n).then(() => {
                e();
              });
          })
          .catch((e) => {
            i(new Error(`Viewer::loadFile -> Could not load file ${t}`));
          });
    });
  }
  loadSplatBuffer(e, t) {
    return new Promise((n) => {
      this.loadingSpinner.show(),
        this.loadingSpinner.setMessage("Processing splats..."),
        window.setTimeout(() => {
          this.setupSplatMesh(
            e,
            t.splatAlphaRemovalThreshold,
            t.position,
            t.orientation,
            t.halfPrecisionCovariancesOnGPU,
            this.devicePixelRatio
          ),
            this.setupSortWorker(e).then(() => {
              this.loadingSpinner.hide(), n();
            });
        }, 1);
    });
  }
  setupSplatMesh(
    t,
    n = 1,
    o = new e.Vector3(),
    i = new e.Quaternion(),
    s = !1,
    r = 1
  ) {
    const a = t.getSplatCount();
    console.log(`Splat count: ${a}`),
      t.buildPreComputedBuffers(),
      (this.splatMesh = Q.buildMesh(t, n, s, r)),
      this.splatMesh.position.copy(o),
      this.splatMesh.quaternion.copy(i),
      (this.splatMesh.frustumCulled = !1),
      (this.splatMesh.renderOrder = 10),
      this.updateSplatMeshUniforms(),
      (this.splatRenderCount = a);
  }
  setupSortWorker(e) {
    return new Promise((t) => {
      const n = e.getSplatCount();
      (this.sortWorker = (function (e) {
        const t = new Worker(
            URL.createObjectURL(
              new Blob(["(", X.toString(), ")(self)"], {
                type: "application/javascript",
              })
            )
          ),
          n = atob(
            "AGFzbQEAAAAADAZkeWxpbmsAAAAAAAEXA2AAAGAMf39/f399fX1/f39/AGAAAX8CEgEDZW52Bm1lbW9yeQIDAICABAMEAwABAgc5AxFfX3dhc21fY2FsbF9jdG9ycwAAC3NvcnRJbmRleGVzAAETZW1zY3JpcHRlbl90bHNfaW5pdAACCqAEAwMAAQuUBAEFfwJAIAogCWsiDiAKSSIQBEBB+P///wchDEGIgICAeCEPIA4hDQNAIAIgDUECdCIJaiABIAAgCWooAgBBDGxqIgkoAgQgAygCGGwgCSgCACADKAIIbGogCSgCCCADKAIobGoiCTYCACAJIAwgCSAMSBshDCAJIA8gCSAPShshDyANQQFqIg0gCkcNAAsgAiALQQJ0aiENIAizIA+yIAyyk5UhBSAQRQ0BIA4hCQNAIA0CfyAFIAIgCUECdGooAgAgDGuylCIGi0MAAABPXQRAIAaoDAELQYCAgIB4C0ECdGoiASABKAIAQQFqNgIAIAlBAWoiCSAKRw0ACwwBCyACIAtBAnRqIQ0gCLNDAACAr5QhBUH4////ByEMCyAIQQJPBEAgDSgCACEDQQEhCQNAIAIgCSALakECdGoiASABKAIAIANqIgM2AgAgCUEBaiIJIAhHDQALCyAOQQBKBEAgDiEJA0AgBCAJQQFrIgFBAnQiA2ogACADaigCADYCACAJQQFKIQMgASEJIAMNAAsLIA4gCkEBayIBTARAIAEhCQNAIAQgASACAn8gBSACIAlBAnQiA2ooAgAgDGuylCIGi0MAAABPXQRAIAaoDAELQYCAgIB4CyALakECdGoiCCgCAEEBayIKa0ECdGogACADaigCADYCACAIIAo2AgAgCSAOSiEDIAlBAWshCSADDQALCwsEAEEACw=="
          ),
          o = new Uint8Array(n.length);
        for (let e = 0; e < n.length; e++) o[e] = n.charCodeAt(e);
        return (
          t.postMessage({
            init: {
              sorterWasmBytes: o.buffer,
              splatCount: e,
              Constants: {
                BytesPerFloat: K.BytesPerFloat,
                BytesPerInt: K.BytesPerInt,
                DepthMapRange: K.DepthMapRange,
                MemoryPageSize: K.MemoryPageSize,
              },
            },
          }),
          t
        );
      })(n)),
        (this.sortWorker.onmessage = (o) => {
          if (o.data.sortDone)
            (this.sortRunning = !1),
              this.splatMesh.updateIndexes(
                this.outIndexArray,
                o.data.splatRenderCount
              ),
              (this.lastSortTime = o.data.sortTime);
          else if (o.data.sortCanceled) this.sortRunning = !1;
          else if (o.data.sortSetupPhase1Complete) {
            console.log("Sorting web worker WASM setup complete."),
              this.sortWorker.postMessage({
                positions: this.splatMesh.getCenters().buffer,
              }),
              (this.outIndexArray = new Uint32Array(
                o.data.outIndexBuffer,
                o.data.outIndexOffset,
                e.getSplatCount()
              )),
              (this.inIndexArray = new Uint32Array(
                o.data.inIndexBuffer,
                o.data.inIndexOffset,
                e.getSplatCount()
              ));
            for (let e = 0; e < n; e++) this.inIndexArray[e] = e;
          } else if (o.data.sortSetupComplete) {
            console.log("Sorting web worker ready."),
              this.splatMesh.updateIndexes(
                this.outIndexArray,
                e.getSplatCount()
              );
            const n = this.splatMesh.getSplatDataTextures(),
              o = n.covariances.size,
              i = n.centerColors.size;
            console.log("Covariances texture size: " + o.x + " x " + o.y),
              console.log("Centers/colors texture size: " + i.x + " x " + i.y),
              this.updateView(!0, !0),
              (this.splatRenderingInitialized = !0),
              t();
          }
        });
    });
  }
  gatherSceneNodes = (function () {
    const t = [],
      n = new e.Vector3(),
      o = new e.Vector3(),
      i = new e.Vector3(),
      s = new e.Matrix4(),
      r = new e.Vector3(),
      a = new e.Vector3(0, 0, -1),
      c = new e.Vector3(),
      l = (e) => c.copy(e.max).sub(e.min).length();
    return function (c) {
      this.getRenderDimensions(r);
      const h = r.y / 2 / Math.tan((this.camera.fov / 2) * e.MathUtils.DEG2RAD),
        p = Math.atan(r.x / 2 / h),
        u = Math.atan(r.y / 2 / h),
        d = Math.cos(p),
        m = Math.cos(u);
      s.copy(this.camera.matrixWorld).invert(),
        s.multiply(this.splatMesh.matrixWorld);
      const f = this.splatMesh.getSplatTree();
      let y = 0,
        g = 0;
      const C = f.nodesWithIndexes.length;
      for (let e = 0; e < C; e++) {
        const r = f.nodesWithIndexes[e];
        i.copy(r.center).applyMatrix4(s);
        const h = i.length();
        i.normalize(),
          n.copy(i).setX(0).normalize(),
          o.copy(i).setY(0).normalize();
        const p = a.dot(o),
          u = a.dot(n),
          C = l(r);
        (!c && (p < d - 0.5 || u < m - 0.5 || h > 125) && h > C) ||
          ((g += r.data.indexes.length),
          (t[y] = r),
          (r.data.distanceToNode = h),
          y++);
      }
      (t.length = y),
        t.sort((e, t) =>
          e.data.distanceToNode < t.data.distanceToNode ? 1 : -1
        ),
        (this.splatRenderCount = g),
        (this.splatSortCount = 0);
      let v = g * K.BytesPerInt;
      for (let e = 0; e < y; e++) {
        const n = t[e];
        n.data.distanceToNode <= 125 &&
          (this.splatSortCount += n.data.indexes.length);
        const o = n.data.indexes.length,
          i = o * K.BytesPerInt;
        new Uint32Array(this.inIndexArray.buffer, v - i, o).set(n.data.indexes),
          (v -= i);
      }
    };
  })();
  start() {
    if (!this.selfDrivenMode)
      throw new Error("Cannot start viewer unless it is in self driven mode.");
    window.gaussianRequestAnimationFrameId = requestAnimationFrame(this.selfDrivenUpdateFunc),
      (this.selfDrivenModeRunning = !0);
  }
  stop() {
    this.selfDrivenMode &&
      this.selfDrivenModeRunning &&
      (cancelAnimationFrame(window.gaussianRequestAnimationFrameId), (this.selfDrivenModeRunning = !1));
    
  }
  updateFPS = (function () {
    let e = b(),
      t = 0;
    return function () {
      const n = b();
      n - e >= 1 ? ((this.currentFPS = t), (t = 0), (e = n)) : t++;
    };
  })();
  updateForRendererSizeChanges = (function () {
    const t = new e.Vector2(),
      n = new e.Vector2();
    return function () {
      this.renderer.getSize(n),
        (n.x === t.x && n.y === t.y) ||
          (this.usingExternalCamera ||
            ((this.camera.aspect = n.x / n.y),
            this.camera.updateProjectionMatrix()),
          this.splatRenderingInitialized &&
            (this.updateSplatMeshUniforms(),
            this.updateSplatRenderTargetForRenderDimensions(n.x, n.y)),
          t.copy(n));
    };
  })();
  selfDrivenUpdate() {
    this.selfDrivenMode && requestAnimationFrame(this.selfDrivenUpdateFunc),
      this.update(),
      this.render();
  }
  update() {
    this.controls && this.controls.update(),
      this.updateView(),
      this.updateForRendererSizeChanges(),
      this.updateMeshCursor(),
      this.updateFPS(),
      this.timingSensitiveUpdates(),
      this.updateInfo(),
      this.updateControlPlane();
  }
  timingSensitiveUpdates = (function () {
    let e;
    return function () {
      const t = b();
      e || (e = t);
      const n = t - e;
      this.updateCameraTransition(t), this.updateFocusMarker(n), (e = t);
    };
  })();
  updateCameraTransition = (function () {
    let t = new e.Vector3(),
      n = new e.Vector3(),
      o = new e.Vector3();
    return function (e) {
      if (this.transitioningCameraTarget) {
        n.copy(this.previousCameraTarget).sub(this.camera.position).normalize(),
          o.copy(this.nextCameraTarget).sub(this.camera.position).normalize();
        const i = Math.acos(n.dot(o)),
          s =
            (((i / (Math.PI / 3)) * 0.65 + 0.3) / i) *
            (e - this.transitioningCameraTargetStartTime);
        t.copy(this.previousCameraTarget).lerp(this.nextCameraTarget, s),
          this.camera.lookAt(t),
          this.controls.target.copy(t),
          s >= 1 && (this.transitioningCameraTarget = !1);
      }
    };
  })();
  updateFocusMarker = (function () {
    const t = new e.Vector2();
    let n = !1;
    return function (e) {
      this.getRenderDimensions(t);
      if (this.transitioningCameraTarget) {
        this.sceneHelper.setFocusMarkerVisibility(!0);
        const o = Math.max(this.sceneHelper.getFocusMarkerOpacity(), 0);
        let i = Math.min(o + 10 * e, 1);
        this.sceneHelper.setFocusMarkerOpacity(i),
          this.sceneHelper.updateFocusMarker(
            this.nextCameraTarget,
            this.camera,
            t
          ),
          (n = !0);
      } else {
        let o;
        if (
          ((o = n ? 1 : Math.min(this.sceneHelper.getFocusMarkerOpacity(), 1)),
          o > 0)
        ) {
          this.sceneHelper.updateFocusMarker(
            this.nextCameraTarget,
            this.camera,
            t
          );
          let n = Math.max(o - 2.5 * e, 0);
          this.sceneHelper.setFocusMarkerOpacity(n),
            0 === n && this.sceneHelper.setFocusMarkerVisibility(!1);
        }
        n = !1;
      }
    };
  })();
  updateMeshCursor = (function () {
    const t = [],
      n = new e.Vector2();
    return function () {
      this.showMeshCursor
        ? (this.getRenderDimensions(n),
          (t.length = 0),
          this.raycaster.setFromCameraAndScreenPosition(
            this.camera,
            this.mousePosition,
            n
          ),
          this.raycaster.intersectSplatMesh(this.splatMesh, t),
          t.length > 0
            ? (this.sceneHelper.setMeshCursorVisibility(!0),
              this.sceneHelper.positionAndOrientMeshCursor(
                t[0].origin,
                this.camera
              ))
            : this.sceneHelper.setMeshCursorVisibility(!1))
        : this.sceneHelper.setMeshCursorVisibility(!1);
    };
  })();
  updateInfo = (function () {
    const t = new e.Vector2();
    return function () {
      if (this.showInfo) {
        const e = this.splatMesh.getSplatCount();
        this.getRenderDimensions(t);
        const n = this.camera.position,
          o = `[${n.x.toFixed(5)}, ${n.y.toFixed(5)}, ${n.z.toFixed(5)}]`;
        this.infoPanelCells.cameraPosition.innerHTML = o;
        const i = this.controls.target,
          s = `[${i.x.toFixed(5)}, ${i.y.toFixed(5)}, ${i.z.toFixed(5)}]`;
        this.infoPanelCells.cameraLookAt.innerHTML = s;
        const r = this.camera.up,
          a = `[${r.x.toFixed(5)}, ${r.y.toFixed(5)}, ${r.z.toFixed(5)}]`;
        if (
          ((this.infoPanelCells.cameraUp.innerHTML = a), this.showMeshCursor)
        ) {
          const e = this.sceneHelper.meshCursor.position,
            t = `[${e.x.toFixed(5)}, ${e.y.toFixed(5)}, ${e.z.toFixed(5)}]`;
          this.infoPanelCells.cursorPosition.innerHTML = t;
        } else this.infoPanelCells.cursorPosition.innerHTML = "N/A";
        (this.infoPanelCells.fps.innerHTML = this.currentFPS),
          (this.infoPanelCells.renderWindow.innerHTML = `${t.x} x ${t.y}`);
        const c = (this.splatRenderCount / e) * 100;
        (this.infoPanelCells.renderSplatCount.innerHTML = `${
          this.splatRenderCount
        } splats out of ${e} (${c.toFixed(2)}%)`),
          (this.infoPanelCells.sortTime.innerHTML = `${this.lastSortTime.toFixed(
            3
          )} ms`);
      }
    };
  })();
  updateControlPlane() {
    this.showControlPlane
      ? (this.sceneHelper.setControlPlaneVisibility(!0),
        this.sceneHelper.positionAndOrientControlPlane(
          this.controls.target,
          this.camera.up
        ))
      : this.sceneHelper.setControlPlaneVisibility(!1);
  }
  render = function () {
    const e = (e) => {
      for (let t of e.children) if (t.visible) return !0;
      return !1;
    };
    let t = e(this.scene),
      n = e(this.simpleScene);
    const o = this.renderer.autoClear;
    (this.renderer.autoClear = !1),
      (t || n) &&
        (t && this.renderer.render(this.scene, this.camera),
        n && this.renderer.render(this.simpleScene, this.camera)),
      this.renderer.render(this.splatMesh, this.camera),
      this.sceneHelper.getFocusMarkerOpacity() > 0 &&
        this.renderer.render(this.sceneHelper.focusMarker, this.camera),
      this.showControlPlane &&
        this.renderer.render(this.sceneHelper.controlPlane, this.camera),
      (this.renderer.autoClear = o);
  };
  updateView = (function () {
    const t = new e.Matrix4(),
      n = [],
      o = new e.Vector3(0, 0, -1),
      i = new e.Vector3(0, 0, -1),
      s = new e.Vector3(),
      r = new e.Vector3();
    return function (e = !1, a = !1) {
      if (!e) {
        i.set(0, 0, -1).applyQuaternion(this.camera.quaternion);
        let e = !1,
          t = !1;
        if (
          (i.dot(o) <= 0.95 && (e = !0),
          r.copy(this.camera.position).sub(s).length() >= 1 && (t = !0),
          !e && !t)
        )
          return;
      }
      t.copy(this.camera.matrixWorld).invert(),
        t.premultiply(this.camera.projectionMatrix),
        t.multiply(this.splatMesh.matrixWorld),
        (n[0] = this.camera.position.x),
        (n[1] = this.camera.position.y),
        (n[2] = this.camera.position.z),
        this.sortRunning ||
          (this.gatherSceneNodes(a),
          (this.sortRunning = !0),
          this.sortWorker.postMessage({
            sort: {
              view: t.elements,
              cameraPosition: n,
              splatRenderCount: this.splatRenderCount,
              splatSortCount: this.splatSortCount,
              inIndexBuffer: this.inIndexArray.buffer,
            },
          }),
          s.copy(this.camera.position),
          o.copy(i));
    };
  })();
  getSplatMesh() {
    return this.splatMesh;
  }
}
export {
  S as PlyLoader,
  P as PlyParser,
  v as SplatBuffer,
  D as SplatLoader,
  $ as Viewer,
};
//# sourceMappingURL=gaussian-splats-3d.module.min.js.map
